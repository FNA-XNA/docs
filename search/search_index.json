{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is FNA? FNA is a reimplementation of the Microsoft XNA Game Studio 4.0 Refresh libraries. FNA is primarily developed by video game porter Ethan Lee , who has shipped more than a dozen ports of XNA games using the exact branch that you see on GitHub today! General information about FNA can be found on the FNA website . Those looking for the original XNA 4.0 Refresh documentation can find it here . How do I use FNA? This wiki is designed to be a step-by-step guide to getting your game running on FNA, whether it's an existing XNA game or a brand new game entirely: The zeroth page is an FAQ, just in case. The first three pages are the essential steps necessary to get any title running on FNA, regardless of any other dependencies your game might have. The second page in particular is split up for existing XNA games as well as new games. The fourth and fifth pages go over common mistakes made by XNA games that obstruct the portability provided by FNA and some solutions that can quickly resolve those mistakes. The fifth page also describes features added to FNA that allow further portability and various enhancements to the user experience. The sixth and seventh pages go over ways that FNA can be optimized and tuned specially for your game, as well as some additional materials related to debugging with FNA. Modders may also find these sections interesting when modifying the FNA binary provided with your game. The final page is a rough guide on how you can contribute to FNA's development. It is strongly suggested that you read the documentation in the order provided, and that you read the documentation in full , as every page is meant to be useful to any developer working with FNA. You might be surprised by what you can really do with this library!","title":"Home"},{"location":"#what-is-fna","text":"FNA is a reimplementation of the Microsoft XNA Game Studio 4.0 Refresh libraries. FNA is primarily developed by video game porter Ethan Lee , who has shipped more than a dozen ports of XNA games using the exact branch that you see on GitHub today! General information about FNA can be found on the FNA website . Those looking for the original XNA 4.0 Refresh documentation can find it here .","title":"What is FNA?"},{"location":"#how-do-i-use-fna","text":"This wiki is designed to be a step-by-step guide to getting your game running on FNA, whether it's an existing XNA game or a brand new game entirely: The zeroth page is an FAQ, just in case. The first three pages are the essential steps necessary to get any title running on FNA, regardless of any other dependencies your game might have. The second page in particular is split up for existing XNA games as well as new games. The fourth and fifth pages go over common mistakes made by XNA games that obstruct the portability provided by FNA and some solutions that can quickly resolve those mistakes. The fifth page also describes features added to FNA that allow further portability and various enhancements to the user experience. The sixth and seventh pages go over ways that FNA can be optimized and tuned specially for your game, as well as some additional materials related to debugging with FNA. Modders may also find these sections interesting when modifying the FNA binary provided with your game. The final page is a rough guide on how you can contribute to FNA's development. It is strongly suggested that you read the documentation in the order provided, and that you read the documentation in full , as every page is meant to be useful to any developer working with FNA. You might be surprised by what you can really do with this library!","title":"How do I use FNA?"},{"location":"0%3A-FAQ/","text":"0: FAQ How can I financially contribute to FNA's development? Currently the only way is through GitHub Sponsors . 100% of your contribution goes directly to the lead maintainer (unlike competing crowdfunding services) and your payment information is securely stored and not shared with the FNA team in any way (i.e. \"you don't have to give Some Random Guy your credit card information\"). What is the difference between FNA and MonoGame? Please read the documentation regarding compatibility between the two . For any deeper comparison, the only way to know the difference is to run both of them yourself. I'm new to programming and- Hi there! Glad you've taken an interest in programming. Please do not use FNA yet. While FNA is a programming tool, it is targeted specifically at experienced programmers. If you are not familiar with C# and msbuild (via Visual Studio, MonoDevelop, or maybe just the XML format?) you will not have a good experience. It is required that you learn at least the basics of the above, and also the difference between managed and native code, before using FNA. I was following a tutorial from Website X and- Unless it came directly from this wiki, do NOT use any third party documentation! Most tutorials are very poorly written and completely unmaintained; if there was a good tutorial we would have endorsed it on the front page of our wiki. It's rare to see a tutorial that even gets the development environment right (see below). Our documentation is minimal, but straightforward for experienced C# programmers (see above). What development environments are supported? The only officially supported environments are the following: The environment described on Page 1 MonoDevelop on Fedora Workstation using the mono-project.com repository, targeting .NET Framework with FNA.csproj Visual Studio 2010 or newer on Windows, targeting .NET Framework with FNA.csproj Visual Studio 2019 or newer on Windows, targeting consoles with NativeAOT and FNA.Core.csproj Visual Studio for Mac, targeting iOS/tvOS with FNA.Core.csproj All other environments and runtimes are unsupported and should not be used. Where is the NuGet package? FNA and its sublibraries do not use NuGet in any capacity. We strongly recommend avoiding NuGet in general, and for FNA we recommend adding FNA.csproj (or FNA.Core.csproj) directly to your solution. FNA itself compiles almost instantly, and debug builds are incredibly valuable to have during development. Any and all NuGet packages for any of our code (FNA, SDL3#, etc.) are unauthorized and should be avoided. If the package claims that we're the authors, please report the package as it is misrepresenting its authors and potentially violating the copyright license (i.e. \"... must not be misrepresented as being the original software\"). What is the FNA content system? FNA supports the XNA content pipeline for preservation reasons, but we strongly recommend against using it on new projects. FNA supports loading common data formats like PNG, WAV and OGG directly, and the community maintains a few libraries for font loading and rendering. For anything more specialized you can bring in an external library or write your own processing and importing tools. Your content system does not have to be complex and there is nothing wrong with simple approaches like loading textures from PNG files. How do I use shaders with FNA? FNA uses Direct3D 9 Effects, to match XNA's shader content format. Using fxc.exe, ideally from the DirectX SDK: fxc.exe /T fx_2_0 MyEffect.fx /Fo MyEffect.fxb Other shader formats, languages, etc are not and will not be supported. While FXC is a Windows binary, the native d3dcompiler used to build these binaries is known to work with Wine. Where is support for GLSL, raw HLSL, SM4+... Per the line directly above : Other shader formats, languages, etc are not and will not be supported. If you want a different shader pipeline you are strongly encouraged to use SDL_GPU instead, possibly with SDL_shadercross . Where is Android support? Android is not and cannot be supported. The solution you just thought of does not work. No, not that other one either. Or even the one someone got booting, almost . Internally, we have what's called a \"body count\" for anyone that tries to add support. It was pretty funny, at least for the first dozen increments. We intend to look at Fuchsia once production devices are available. In the meantime, FNA is known to work on PinePhone with various Free mobile operating systems. I get a BadImageFormatException, and- You mixed up 32- and 64-bit binaries. As it turns out, Microsoft broke their CPU arch configuration in two ways: They added a flag to AnyCPU to make it default to 32-bit even on 64-bit Windows. It's a checkbox in your project settings, uncheck it. They made it so new projects don't actually have x86 and x64 configs, only AnyCPU, so you may have added FNA to your solution only to get an x64 entry in your platform dropdown that isn't actually x64! Feel free to keep using AnyCPU and ignore x86/x64 once you've unchecked Prefer 32-bit, but if it's any consolation you can probably just make an x64 config for your project and always use that, so there's no ambiguity as to what arch you're targeting. (Also, once you've done all this, delete bin/ and obj/. No, we don't know why you need to do this.) I have a bug when running on VirtualBox, and- The bug is that you are using VirtualBox. Please use VMware Player instead. I have a bug when running on system Mono, and- Your LD_LIBRARY_PATH is busted. You can do one of three things: Preserve the lib64 folder (like you're supposed to anyway) and set LD_LIBRARY_PATH to include that folder Delete your output's copy of libSDL3.so.0, keeping the rest of the libs next to your exe, and be sure your distribution provides the latest stable SDL release (maybe don't do this one since it's not the official build) Throw the fnalibs into /usr/local/lib (definitely don't do this one) For shipping builds, use MonoKickstart , do NOT use system dependencies! Where can I get fnalibs for CPU architecture X? If it is not included in the standard fnalibs.zip you will need to build the libraries from source. The instructions for each library can be found in their respective README files. What happens if I ask a question that's answered in this wiki? * Bubs voice * That'll be five dollars . No, this isn't a joke. Expect a link to the sponsors page for each of your requests.","title":"0: FAQ"},{"location":"0%3A-FAQ/#0-faq","text":"","title":"0: FAQ"},{"location":"0%3A-FAQ/#how-can-i-financially-contribute-to-fnas-development","text":"Currently the only way is through GitHub Sponsors . 100% of your contribution goes directly to the lead maintainer (unlike competing crowdfunding services) and your payment information is securely stored and not shared with the FNA team in any way (i.e. \"you don't have to give Some Random Guy your credit card information\").","title":"How can I financially contribute to FNA's development?"},{"location":"0%3A-FAQ/#what-is-the-difference-between-fna-and-monogame","text":"Please read the documentation regarding compatibility between the two . For any deeper comparison, the only way to know the difference is to run both of them yourself.","title":"What is the difference between FNA and MonoGame?"},{"location":"0%3A-FAQ/#im-new-to-programming-and-","text":"Hi there! Glad you've taken an interest in programming. Please do not use FNA yet. While FNA is a programming tool, it is targeted specifically at experienced programmers. If you are not familiar with C# and msbuild (via Visual Studio, MonoDevelop, or maybe just the XML format?) you will not have a good experience. It is required that you learn at least the basics of the above, and also the difference between managed and native code, before using FNA.","title":"I'm new to programming and-"},{"location":"0%3A-FAQ/#i-was-following-a-tutorial-from-website-x-and-","text":"Unless it came directly from this wiki, do NOT use any third party documentation! Most tutorials are very poorly written and completely unmaintained; if there was a good tutorial we would have endorsed it on the front page of our wiki. It's rare to see a tutorial that even gets the development environment right (see below). Our documentation is minimal, but straightforward for experienced C# programmers (see above).","title":"I was following a tutorial from Website X and-"},{"location":"0%3A-FAQ/#what-development-environments-are-supported","text":"The only officially supported environments are the following: The environment described on Page 1 MonoDevelop on Fedora Workstation using the mono-project.com repository, targeting .NET Framework with FNA.csproj Visual Studio 2010 or newer on Windows, targeting .NET Framework with FNA.csproj Visual Studio 2019 or newer on Windows, targeting consoles with NativeAOT and FNA.Core.csproj Visual Studio for Mac, targeting iOS/tvOS with FNA.Core.csproj All other environments and runtimes are unsupported and should not be used.","title":"What development environments are supported?"},{"location":"0%3A-FAQ/#where-is-the-nuget-package","text":"FNA and its sublibraries do not use NuGet in any capacity. We strongly recommend avoiding NuGet in general, and for FNA we recommend adding FNA.csproj (or FNA.Core.csproj) directly to your solution. FNA itself compiles almost instantly, and debug builds are incredibly valuable to have during development. Any and all NuGet packages for any of our code (FNA, SDL3#, etc.) are unauthorized and should be avoided. If the package claims that we're the authors, please report the package as it is misrepresenting its authors and potentially violating the copyright license (i.e. \"... must not be misrepresented as being the original software\").","title":"Where is the NuGet package?"},{"location":"0%3A-FAQ/#what-is-the-fna-content-system","text":"FNA supports the XNA content pipeline for preservation reasons, but we strongly recommend against using it on new projects. FNA supports loading common data formats like PNG, WAV and OGG directly, and the community maintains a few libraries for font loading and rendering. For anything more specialized you can bring in an external library or write your own processing and importing tools. Your content system does not have to be complex and there is nothing wrong with simple approaches like loading textures from PNG files.","title":"What is the FNA content system?"},{"location":"0%3A-FAQ/#how-do-i-use-shaders-with-fna","text":"FNA uses Direct3D 9 Effects, to match XNA's shader content format. Using fxc.exe, ideally from the DirectX SDK: fxc.exe /T fx_2_0 MyEffect.fx /Fo MyEffect.fxb Other shader formats, languages, etc are not and will not be supported. While FXC is a Windows binary, the native d3dcompiler used to build these binaries is known to work with Wine.","title":"How do I use shaders with FNA?"},{"location":"0%3A-FAQ/#where-is-support-for-glsl-raw-hlsl-sm4","text":"Per the line directly above : Other shader formats, languages, etc are not and will not be supported. If you want a different shader pipeline you are strongly encouraged to use SDL_GPU instead, possibly with SDL_shadercross .","title":"Where is support for GLSL, raw HLSL, SM4+..."},{"location":"0%3A-FAQ/#where-is-android-support","text":"Android is not and cannot be supported. The solution you just thought of does not work. No, not that other one either. Or even the one someone got booting, almost . Internally, we have what's called a \"body count\" for anyone that tries to add support. It was pretty funny, at least for the first dozen increments. We intend to look at Fuchsia once production devices are available. In the meantime, FNA is known to work on PinePhone with various Free mobile operating systems.","title":"Where is Android support?"},{"location":"0%3A-FAQ/#i-get-a-badimageformatexception-and-","text":"You mixed up 32- and 64-bit binaries. As it turns out, Microsoft broke their CPU arch configuration in two ways: They added a flag to AnyCPU to make it default to 32-bit even on 64-bit Windows. It's a checkbox in your project settings, uncheck it. They made it so new projects don't actually have x86 and x64 configs, only AnyCPU, so you may have added FNA to your solution only to get an x64 entry in your platform dropdown that isn't actually x64! Feel free to keep using AnyCPU and ignore x86/x64 once you've unchecked Prefer 32-bit, but if it's any consolation you can probably just make an x64 config for your project and always use that, so there's no ambiguity as to what arch you're targeting. (Also, once you've done all this, delete bin/ and obj/. No, we don't know why you need to do this.)","title":"I get a BadImageFormatException, and-"},{"location":"0%3A-FAQ/#i-have-a-bug-when-running-on-virtualbox-and-","text":"The bug is that you are using VirtualBox. Please use VMware Player instead.","title":"I have a bug when running on VirtualBox, and-"},{"location":"0%3A-FAQ/#i-have-a-bug-when-running-on-system-mono-and-","text":"Your LD_LIBRARY_PATH is busted. You can do one of three things: Preserve the lib64 folder (like you're supposed to anyway) and set LD_LIBRARY_PATH to include that folder Delete your output's copy of libSDL3.so.0, keeping the rest of the libs next to your exe, and be sure your distribution provides the latest stable SDL release (maybe don't do this one since it's not the official build) Throw the fnalibs into /usr/local/lib (definitely don't do this one) For shipping builds, use MonoKickstart , do NOT use system dependencies!","title":"I have a bug when running on system Mono, and-"},{"location":"0%3A-FAQ/#where-can-i-get-fnalibs-for-cpu-architecture-x","text":"If it is not included in the standard fnalibs.zip you will need to build the libraries from source. The instructions for each library can be found in their respective README files.","title":"Where can I get fnalibs for CPU architecture X?"},{"location":"0%3A-FAQ/#what-happens-if-i-ask-a-question-thats-answered-in-this-wiki","text":"* Bubs voice * That'll be five dollars . No, this isn't a joke. Expect a link to the sponsors page for each of your requests.","title":"What happens if I ask a question that's answered in this wiki?"},{"location":"1%3A-Setting-Up-FNA/","text":"1: Setting Up FNA This page has two parts: The first sets up the FNA team's recommended development environment, and the second prepares FNA itself. If you already have a development environment you like, you can skip to the Download FNA section if you want, but note that our environment prepares you for remote debugging on Steam Deck . Chapter 1a: Linux Setup The Linux development environment for FNA is supported on all distributions with Flatpak support, including SteamOS! (But, if you absolutely must know, the FNA team uses Fedora Workstation .) You may be able to find VSCode and the .NET SDKs via apps like KDE Discover, but it's easier to get everything at once with a single portable terminal command: flatpak install com.visualstudio.code org.freedesktop.Sdk.Extension.mono6 org.freedesktop.Sdk.Extension.dotnet8 This installs VSCode, Mono, and .NET 8 all at once! If it asks which version of the SDKs to install, select 24.08. All that's left is to expose the .NET and Mono SDKs to VSCode's sandbox: flatpak --user override --env=FLATPAK_ENABLE_SDK_EXT=mono6,dotnet8 com.visualstudio.code Chapter 1b: Windows Setup At minimum you will need to install the following software: Visual Studio Code .NET 8 SDK .NET 4.6.2 Developer Pack Mono for 64-bit Windows When setting up projects, Windows has an additional setup step. An important part of multiplatform development is filesystem case sensitivity - for example, on Linux and console platforms, \"filename\" is NOT the same as \"FileName\"! To ensure that developers follow this rule, it is recommended to make your project folders case sensitive on Windows. To do this, open a Command Prompt as Administrator, then (carefully!) enter the following command: fsutil.exe file SetCaseSensitiveInfo \"C:\\path\\to\\your\\project\" enable (While we're on the subject, remember not to use \\\\ for file paths !) Chapter 2: Visual Studio Code Extensions After starting VSCode, hit Ctrl+Shift+X to go to the extensions view, then search for \"C# Dev Kit\". Install the kit from the marketplace and let it download all of the components. You should be able to clear the search results and see the various new installed extensions! Lastly, search for and install the \"Mono Debug\" extension. Chapter 3: Download and Update FNA We strongly recommend using Git to download and update FNA. This tutorial will guide you through this process. If you are using an official zipped release of FNA, you only need to worry about step 2. Step 1: Clone FNA FNA uses several Git submodules to access the source to additional libraries, such as SDL3# and FAudio. To fully download FNA, add the --recursive parameter to your git clone command: git clone --recursive https://github.com/FNA-XNA/FNA This will clone FNA, then clone all of the submodules into the appropriate locations. Step 2: Download Native Libraries FNA uses several native libraries for various pieces of functionality, such as window management, input, and audio output. Here's what we use and why: SDL: Used for window management, input, image I/O, etc. FNA3D: Only required if you use the Graphics namespace. FAudio: Only required if you use the Audio or Media namespaces. Theorafile: Only required if you use VideoPlayer. You can find the libraries precompiled at our fnalibs-dailies repository. The \"fnalibs\" archive contains all of the native libraries for Windows and Linux. Step 3: Update FNA It is strongly recommended that you update at least once a month. FNA releases are always on the first of every month, so you may simply want to make a calendar reminder for yourself to redownload FNA and fnalibs.zip at the beginning of each month. To update FNA, simply enter the FNA directory and run git pull . This will update to the latest FNA version, assuming you have not made local changes that conflict with the upstream changes. If you do have local changes, store them elsewhere and update, or revert your changes. (By the way, if you really do have local changes, please let us know! We want working code in upstream, and it will make your life easier, we promise!) Sometimes, FNA will update one of its submodules. When this occurs, run git submodule update --init --recursive and the submodules will fully update. Again, this assumes that you have not made local changes to the submodules. Step 4: Join the FNA Discord Aside from the commit log, a good place to keep an eye on major FNA changes is to join the Discord server . This is where announcements and development discussion occur; in particular, there are channels allocated for general development, XNA preservation research, private console development, and experimental platform development. Chapter 4: Building Old Visual Studio Projects For those using old pre-.NET Core solutions, you will want to make these changes to allow building your solution: Right click the C# Dev Kit extension and disable it, leaving all other extensions alone Right click the C# extension and select Extension Settings Search for useModernDotNet, uncheck Use Modern .NET Search for useOmnisharp, check Use Omnisharp Create a .vscode folder next to your solution, then add a tasks.json file containing something like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"command\": \"msbuild\", \"args\": [ // Ask msbuild to generate full paths for file names. \"/property:GenerateFullPaths=true\", \"/t:build\", // Do not generate summary otherwise it leads to duplicate errors in Problems panel \"/consoleloggerparameters:NoSummary\", \"THIS_IS_YOUR_GAME.sln\", \"/p:Configuration=Debug\" ], \"group\": \"build\", \"presentation\": { // Reveal the output only if unrecognized errors occur. \"reveal\": \"silent\" }, // Use the standard MS compiler pattern to detect errors, warnings and infos \"problemMatcher\": \"$msCompile\" } ] } With this in place, you should now be able to build ( Terminal -> Run Build Task )! Chapter 5: Creating New Projects Making an FNA project is relatively simple for basically every C# IDE, though the process has changed in recent years: For Visual Studio Code, you can use the built-in terminal to navigate to your project folder, then run dotnet new sln --name YourProjectName to create a new solution, dotnet new console --name YourProjectName to create an empty project, and dotnet sln add YourProjectName/YourProjectName.csproj to add it to the solution. Visual Studio and MonoDevelop have New Solution wizards for creating empty C# projects. Once the empty project is created, you can go to the Solution Explorer and right click the solution, click \"Add Existing Project\", then add FNA (FNA.NetFramework.csproj for .NET Framework and Mono, FNA.Core.csproj for .NET 8, or FNA.csproj for old Visual Studio projects). You can then right click the empty project and add FNA as a Project Reference. For existing XNA projects, we recommend targeting .NET Framework and Mono for better compatibility. For new projects, we recommend .NET 8. .NET Framework Fixes When targeting .NET Framework via Visual Studio Code, be sure to open YourProjectName/YourProjectName.csproj and change the target framework to net4.0 ! You'll also find that running/debugging takes a few more steps - we're lobbying to streamline this process, but if you want to get debugging ASAP, you can open the folder where your .sln file is, make a .vscode/ folder, then rip off this launch.json file and place it in the .vscode/ folder: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch\", \"type\": \"mono\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/path/to/your/bin/Debug/net4.0/Game.exe\", \"cwd\": \"${workspaceRoot}\", \"env\": { \"LD_LIBRARY_PATH\": \"${workspaceRoot}/path/to/your/fnalibs/lib64/\" } }, { \"name\": \"Attach\", \"type\": \"mono\", \"request\": \"attach\", \"address\": \"localhost\", \"port\": 55555 } ] } With this in place, you should now be able to launch the program after it's built ( Run -> Start Debugging , or F5!)! .NET Core Fixes DllMap is a critical component of .NET portability that maps native library names to appropriate equivalents on multiple platforms. For example, while Windows might look for fmod_studio.dll , Linux will instead look for libfmodstudio.so.XX , which is nontrivial for the runtime to figure out on its own. By adding a config file like this one , we're able to automatically map DLL names for all platforms without resorting to per-platform builds with customized DLL names. Shamefully, this is currently absent from .NET Core. We will continue to lobby for adding this feature back to modern .NET, but for now we have developed a workaround called FNADllMap . We strongly encourage everyone to copy this file directly and add it to every single project, particularly those that use DllImport, so that all managed EXE/DLL files have a rough equivalent of real DllMap support. Visual Studio AnyCPU Fix For Visual Studio 2019 users, follow these additional steps to allow VS to build your project properly for 64-bit: In the Visual Studio toolbar, click on the Solution Platforms dropdown menu (where it says 'Any CPU'), and click on 'Configuration Manager...' In the Configuration Manager window that appears, change the 'Active solution platform' to x64. Notice that the referenced FNA project changes to x64, but your project remains 'Any CPU' Address this discrepancy by clicking on the platform dropdown for your project and clicking New In the New Project Platform dialog that appears, create a new platform using x64 from the dropdown. Copying settings from Any CPU is fine, and make sure the 'Create new solution platforms' is unchecked You can now build your project for x64!","title":"1: Setting Up FNA"},{"location":"1%3A-Setting-Up-FNA/#1-setting-up-fna","text":"This page has two parts: The first sets up the FNA team's recommended development environment, and the second prepares FNA itself. If you already have a development environment you like, you can skip to the Download FNA section if you want, but note that our environment prepares you for remote debugging on Steam Deck .","title":"1: Setting Up FNA"},{"location":"1%3A-Setting-Up-FNA/#chapter-1a-linux-setup","text":"The Linux development environment for FNA is supported on all distributions with Flatpak support, including SteamOS! (But, if you absolutely must know, the FNA team uses Fedora Workstation .) You may be able to find VSCode and the .NET SDKs via apps like KDE Discover, but it's easier to get everything at once with a single portable terminal command: flatpak install com.visualstudio.code org.freedesktop.Sdk.Extension.mono6 org.freedesktop.Sdk.Extension.dotnet8 This installs VSCode, Mono, and .NET 8 all at once! If it asks which version of the SDKs to install, select 24.08. All that's left is to expose the .NET and Mono SDKs to VSCode's sandbox: flatpak --user override --env=FLATPAK_ENABLE_SDK_EXT=mono6,dotnet8 com.visualstudio.code","title":"Chapter 1a: Linux Setup"},{"location":"1%3A-Setting-Up-FNA/#chapter-1b-windows-setup","text":"At minimum you will need to install the following software: Visual Studio Code .NET 8 SDK .NET 4.6.2 Developer Pack Mono for 64-bit Windows When setting up projects, Windows has an additional setup step. An important part of multiplatform development is filesystem case sensitivity - for example, on Linux and console platforms, \"filename\" is NOT the same as \"FileName\"! To ensure that developers follow this rule, it is recommended to make your project folders case sensitive on Windows. To do this, open a Command Prompt as Administrator, then (carefully!) enter the following command: fsutil.exe file SetCaseSensitiveInfo \"C:\\path\\to\\your\\project\" enable (While we're on the subject, remember not to use \\\\ for file paths !)","title":"Chapter 1b: Windows Setup"},{"location":"1%3A-Setting-Up-FNA/#chapter-2-visual-studio-code-extensions","text":"After starting VSCode, hit Ctrl+Shift+X to go to the extensions view, then search for \"C# Dev Kit\". Install the kit from the marketplace and let it download all of the components. You should be able to clear the search results and see the various new installed extensions! Lastly, search for and install the \"Mono Debug\" extension.","title":"Chapter 2: Visual Studio Code Extensions"},{"location":"1%3A-Setting-Up-FNA/#chapter-3-download-and-update-fna","text":"We strongly recommend using Git to download and update FNA. This tutorial will guide you through this process. If you are using an official zipped release of FNA, you only need to worry about step 2.","title":"Chapter 3: Download and Update FNA"},{"location":"1%3A-Setting-Up-FNA/#step-1-clone-fna","text":"FNA uses several Git submodules to access the source to additional libraries, such as SDL3# and FAudio. To fully download FNA, add the --recursive parameter to your git clone command: git clone --recursive https://github.com/FNA-XNA/FNA This will clone FNA, then clone all of the submodules into the appropriate locations.","title":"Step 1: Clone FNA"},{"location":"1%3A-Setting-Up-FNA/#step-2-download-native-libraries","text":"FNA uses several native libraries for various pieces of functionality, such as window management, input, and audio output. Here's what we use and why: SDL: Used for window management, input, image I/O, etc. FNA3D: Only required if you use the Graphics namespace. FAudio: Only required if you use the Audio or Media namespaces. Theorafile: Only required if you use VideoPlayer. You can find the libraries precompiled at our fnalibs-dailies repository. The \"fnalibs\" archive contains all of the native libraries for Windows and Linux.","title":"Step 2: Download Native Libraries"},{"location":"1%3A-Setting-Up-FNA/#step-3-update-fna","text":"It is strongly recommended that you update at least once a month. FNA releases are always on the first of every month, so you may simply want to make a calendar reminder for yourself to redownload FNA and fnalibs.zip at the beginning of each month. To update FNA, simply enter the FNA directory and run git pull . This will update to the latest FNA version, assuming you have not made local changes that conflict with the upstream changes. If you do have local changes, store them elsewhere and update, or revert your changes. (By the way, if you really do have local changes, please let us know! We want working code in upstream, and it will make your life easier, we promise!) Sometimes, FNA will update one of its submodules. When this occurs, run git submodule update --init --recursive and the submodules will fully update. Again, this assumes that you have not made local changes to the submodules.","title":"Step 3: Update FNA"},{"location":"1%3A-Setting-Up-FNA/#step-4-join-the-fna-discord","text":"Aside from the commit log, a good place to keep an eye on major FNA changes is to join the Discord server . This is where announcements and development discussion occur; in particular, there are channels allocated for general development, XNA preservation research, private console development, and experimental platform development.","title":"Step 4: Join the FNA Discord"},{"location":"1%3A-Setting-Up-FNA/#chapter-4-building-old-visual-studio-projects","text":"For those using old pre-.NET Core solutions, you will want to make these changes to allow building your solution: Right click the C# Dev Kit extension and disable it, leaving all other extensions alone Right click the C# extension and select Extension Settings Search for useModernDotNet, uncheck Use Modern .NET Search for useOmnisharp, check Use Omnisharp Create a .vscode folder next to your solution, then add a tasks.json file containing something like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"command\": \"msbuild\", \"args\": [ // Ask msbuild to generate full paths for file names. \"/property:GenerateFullPaths=true\", \"/t:build\", // Do not generate summary otherwise it leads to duplicate errors in Problems panel \"/consoleloggerparameters:NoSummary\", \"THIS_IS_YOUR_GAME.sln\", \"/p:Configuration=Debug\" ], \"group\": \"build\", \"presentation\": { // Reveal the output only if unrecognized errors occur. \"reveal\": \"silent\" }, // Use the standard MS compiler pattern to detect errors, warnings and infos \"problemMatcher\": \"$msCompile\" } ] } With this in place, you should now be able to build ( Terminal -> Run Build Task )!","title":"Chapter 4: Building Old Visual Studio Projects"},{"location":"1%3A-Setting-Up-FNA/#chapter-5-creating-new-projects","text":"Making an FNA project is relatively simple for basically every C# IDE, though the process has changed in recent years: For Visual Studio Code, you can use the built-in terminal to navigate to your project folder, then run dotnet new sln --name YourProjectName to create a new solution, dotnet new console --name YourProjectName to create an empty project, and dotnet sln add YourProjectName/YourProjectName.csproj to add it to the solution. Visual Studio and MonoDevelop have New Solution wizards for creating empty C# projects. Once the empty project is created, you can go to the Solution Explorer and right click the solution, click \"Add Existing Project\", then add FNA (FNA.NetFramework.csproj for .NET Framework and Mono, FNA.Core.csproj for .NET 8, or FNA.csproj for old Visual Studio projects). You can then right click the empty project and add FNA as a Project Reference. For existing XNA projects, we recommend targeting .NET Framework and Mono for better compatibility. For new projects, we recommend .NET 8.","title":"Chapter 5: Creating New Projects"},{"location":"1%3A-Setting-Up-FNA/#net-framework-fixes","text":"When targeting .NET Framework via Visual Studio Code, be sure to open YourProjectName/YourProjectName.csproj and change the target framework to net4.0 ! You'll also find that running/debugging takes a few more steps - we're lobbying to streamline this process, but if you want to get debugging ASAP, you can open the folder where your .sln file is, make a .vscode/ folder, then rip off this launch.json file and place it in the .vscode/ folder: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch\", \"type\": \"mono\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/path/to/your/bin/Debug/net4.0/Game.exe\", \"cwd\": \"${workspaceRoot}\", \"env\": { \"LD_LIBRARY_PATH\": \"${workspaceRoot}/path/to/your/fnalibs/lib64/\" } }, { \"name\": \"Attach\", \"type\": \"mono\", \"request\": \"attach\", \"address\": \"localhost\", \"port\": 55555 } ] } With this in place, you should now be able to launch the program after it's built ( Run -> Start Debugging , or F5!)!","title":".NET Framework Fixes"},{"location":"1%3A-Setting-Up-FNA/#net-core-fixes","text":"DllMap is a critical component of .NET portability that maps native library names to appropriate equivalents on multiple platforms. For example, while Windows might look for fmod_studio.dll , Linux will instead look for libfmodstudio.so.XX , which is nontrivial for the runtime to figure out on its own. By adding a config file like this one , we're able to automatically map DLL names for all platforms without resorting to per-platform builds with customized DLL names. Shamefully, this is currently absent from .NET Core. We will continue to lobby for adding this feature back to modern .NET, but for now we have developed a workaround called FNADllMap . We strongly encourage everyone to copy this file directly and add it to every single project, particularly those that use DllImport, so that all managed EXE/DLL files have a rough equivalent of real DllMap support.","title":".NET Core Fixes"},{"location":"1%3A-Setting-Up-FNA/#visual-studio-anycpu-fix","text":"For Visual Studio 2019 users, follow these additional steps to allow VS to build your project properly for 64-bit: In the Visual Studio toolbar, click on the Solution Platforms dropdown menu (where it says 'Any CPU'), and click on 'Configuration Manager...' In the Configuration Manager window that appears, change the 'Active solution platform' to x64. Notice that the referenced FNA project changes to x64, but your project remains 'Any CPU' Address this discrepancy by clicking on the platform dropdown for your project and clicking New In the New Project Platform dialog that appears, create a new platform using x64 from the dropdown. Copying settings from Any CPU is fine, and make sure the 'Create new solution platforms' is unchecked You can now build your project for x64!","title":"Visual Studio AnyCPU Fix"},{"location":"2a%3A-Building-XNA-Games-with-FNA/","text":"2a: Building XNA Games with FNA This is a guide to getting your existing XNA game running on FNA. If you are creating a new game, please see this wiki page . Note that this entire guide can be done on Windows - you do not need a Mac or a Linux box to perform anything described on this page. Also note that this is NOT strictly a guide on having your game fully ported to non-XNA platforms! FNA can only make XNA itself portable; whether or not your game is in any way portable is out of our hands. If this is a concern, look at \" FNA and Windows API \". 1. Making the FNA Solution We strongly recommend making a brand new solution for the FNA version. It's possible to fiddle with your XNA solution to link your code against FNA, but it's probably just easier to make YourGame.FNA.sln and keep YourGame.sln as it is. See Page 1 for a quick refresher on how to do this! One thing you will NOT need to recreate is the content projects. When deploying to FNA, your content should already be complete and built. You can keep this in your solution if you like, but you will need to reference the XNA content pipeline here. You should not reference FNA in content projects! (As an aside, if you are creating new content instead of porting existing content, you should not feel pressured to use processing tools like the XNA/MonoGame content pipeline tools! It is perfectly reasonable to develop your own content system that can be designed and optimized to work well with you and your development team, and in fact that is what we recommend doing for new projects.) Once you've remade your solution with all of your game's subprojects, add FNA.csproj into your solution. FNA, despite using many different C# wrappers, is just a single project file. This simplifies project generation and quickly gives you access to, for example, SDL3# if you need it in your game code. Your projects' references are going to be the same as they were in XNA4, except now you will reference FNA instead of the XNA libraries. Once all of the projects have been made and are linking to FNA, your solution should now compile. Simple as that! 2. About Content Support While we do our best to support 100% of the XNA content available, there are a few notable exceptions due to both technical and legal obstacles. 2a. About Effect Support FNA uses MojoShader to parse and rebuild Effect shaders to non-D3D graphics APIs. This allows us to use the original XNB-packed Effects built by XNA and fx_2_0 effect binaries built by FXC , the Effect compiler from the June 2010 DirectX SDK . However, there are exactly three caveats to this: We do not attempt to undo half-pixel offsets applied by the game's shaders. If you don't know what this is, don't worry. If you do know what this is and have applied them in your engine, simply remove them from the FNA version of your game and it should visually match D3D without any problems. Another half-pixel-like issue present is in the VPOS attribute; D3D9 puts the VPOS at integer values while all other graphics APIs put it at half-pixel values (in contrast to the half-pixel offset described above, where it's the exact opposite). If you find that VPOS isn't acting as expected, take the input VPOS value and floor() it before doing anything else in the shader. For maximum compatibility, vertex input layouts must match the vertex shader input parameters exactly . D3D9 and OpenGL would quietly drop input streams that were unused in the vertex shader, but newer graphics APIs like D3D11 and Vulkan are far more strict about this. For example, if your vertex shader expects a TEXCOORD0 input, but your VertexDeclaration does not include a TextureCoordinate with index 0, this is a hard error unless you forcibly use the OpenGL renderer exclusively. 2b. Rebuilding WMA/WMV Files XNA uses Windows Media Player for the Song and the VideoPlayer implementations. Obviously we cannot use this in a multiplatform reimplementation, so currently we do not support WMA/WMV files. Instead, we support Ogg Vorbis and QOA for audio and Ogg Theora for video. 2c. Rebuilding XACT WaveBanks XACT for Windows supports a codec called xWMA for highly-compressed audio streams, rather than the XMA codec typically used on the 360. Like WMA support we do not have support for either of these, but you can still compress your WaveBanks with ADPCM. The file size will likely be larger, but the functionality of your XACT code/content should be exactly the same, and no changes are required if you do not use xWMA or XMA. 3. Window Icons Typically a Windows application will use the embedded .ico image for both the window icon and the icon used in other parts of the OS, such as the taskbar. While this does work on Windows, it actually turns out to be unusable on other platforms, so we instead use a separate bitmap file to set the process icon. For Linux (and optionally Windows, if you want a higher-res icon), simply place a bitmap file in the game's root directory. The bitmap's filename is the same string as the window title, minus the characters that are not allowed for filenames. The recommended image size is at least 512x512, as many desktops will use this icon for more than just the 16x16 image next to the window title. 4. Running the FNA Output Once the FNA version has been built, copy over your Content folder and native libraries (which you should have downloaded along with FNA itself) into the output folder. From there, the game should be able to run! This exact output will be what you run on Linux and Windows. The only difference will be the native libraries in addition to FNA.dll.config , which should be in your output folder even if you're on Windows. FNA.dll.config is what remaps the native DLL names to the proper names of the native libraries on non-Windows operating systems. Aside from this, everything else should work - the C# assemblies, the Content, everything. Push this output to a Linux box and try them out! When using a developer environment on macOS, you will want to add an environment variable that sets DYLD_LIBRARY_PATH=./osx/ , so that the IDE's runtime environment will find the fnalibs binaries.","title":"2a: Building XNA Games with FNA"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#2a-building-xna-games-with-fna","text":"This is a guide to getting your existing XNA game running on FNA. If you are creating a new game, please see this wiki page . Note that this entire guide can be done on Windows - you do not need a Mac or a Linux box to perform anything described on this page. Also note that this is NOT strictly a guide on having your game fully ported to non-XNA platforms! FNA can only make XNA itself portable; whether or not your game is in any way portable is out of our hands. If this is a concern, look at \" FNA and Windows API \".","title":"2a: Building XNA Games with FNA"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#1-making-the-fna-solution","text":"We strongly recommend making a brand new solution for the FNA version. It's possible to fiddle with your XNA solution to link your code against FNA, but it's probably just easier to make YourGame.FNA.sln and keep YourGame.sln as it is. See Page 1 for a quick refresher on how to do this! One thing you will NOT need to recreate is the content projects. When deploying to FNA, your content should already be complete and built. You can keep this in your solution if you like, but you will need to reference the XNA content pipeline here. You should not reference FNA in content projects! (As an aside, if you are creating new content instead of porting existing content, you should not feel pressured to use processing tools like the XNA/MonoGame content pipeline tools! It is perfectly reasonable to develop your own content system that can be designed and optimized to work well with you and your development team, and in fact that is what we recommend doing for new projects.) Once you've remade your solution with all of your game's subprojects, add FNA.csproj into your solution. FNA, despite using many different C# wrappers, is just a single project file. This simplifies project generation and quickly gives you access to, for example, SDL3# if you need it in your game code. Your projects' references are going to be the same as they were in XNA4, except now you will reference FNA instead of the XNA libraries. Once all of the projects have been made and are linking to FNA, your solution should now compile. Simple as that!","title":"1. Making the FNA Solution"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#2-about-content-support","text":"While we do our best to support 100% of the XNA content available, there are a few notable exceptions due to both technical and legal obstacles.","title":"2. About Content Support"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#2a-about-effect-support","text":"FNA uses MojoShader to parse and rebuild Effect shaders to non-D3D graphics APIs. This allows us to use the original XNB-packed Effects built by XNA and fx_2_0 effect binaries built by FXC , the Effect compiler from the June 2010 DirectX SDK . However, there are exactly three caveats to this: We do not attempt to undo half-pixel offsets applied by the game's shaders. If you don't know what this is, don't worry. If you do know what this is and have applied them in your engine, simply remove them from the FNA version of your game and it should visually match D3D without any problems. Another half-pixel-like issue present is in the VPOS attribute; D3D9 puts the VPOS at integer values while all other graphics APIs put it at half-pixel values (in contrast to the half-pixel offset described above, where it's the exact opposite). If you find that VPOS isn't acting as expected, take the input VPOS value and floor() it before doing anything else in the shader. For maximum compatibility, vertex input layouts must match the vertex shader input parameters exactly . D3D9 and OpenGL would quietly drop input streams that were unused in the vertex shader, but newer graphics APIs like D3D11 and Vulkan are far more strict about this. For example, if your vertex shader expects a TEXCOORD0 input, but your VertexDeclaration does not include a TextureCoordinate with index 0, this is a hard error unless you forcibly use the OpenGL renderer exclusively.","title":"2a. About Effect Support"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#2b-rebuilding-wmawmv-files","text":"XNA uses Windows Media Player for the Song and the VideoPlayer implementations. Obviously we cannot use this in a multiplatform reimplementation, so currently we do not support WMA/WMV files. Instead, we support Ogg Vorbis and QOA for audio and Ogg Theora for video.","title":"2b. Rebuilding WMA/WMV Files"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#2c-rebuilding-xact-wavebanks","text":"XACT for Windows supports a codec called xWMA for highly-compressed audio streams, rather than the XMA codec typically used on the 360. Like WMA support we do not have support for either of these, but you can still compress your WaveBanks with ADPCM. The file size will likely be larger, but the functionality of your XACT code/content should be exactly the same, and no changes are required if you do not use xWMA or XMA.","title":"2c. Rebuilding XACT WaveBanks"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#3-window-icons","text":"Typically a Windows application will use the embedded .ico image for both the window icon and the icon used in other parts of the OS, such as the taskbar. While this does work on Windows, it actually turns out to be unusable on other platforms, so we instead use a separate bitmap file to set the process icon. For Linux (and optionally Windows, if you want a higher-res icon), simply place a bitmap file in the game's root directory. The bitmap's filename is the same string as the window title, minus the characters that are not allowed for filenames. The recommended image size is at least 512x512, as many desktops will use this icon for more than just the 16x16 image next to the window title.","title":"3. Window Icons"},{"location":"2a%3A-Building-XNA-Games-with-FNA/#4-running-the-fna-output","text":"Once the FNA version has been built, copy over your Content folder and native libraries (which you should have downloaded along with FNA itself) into the output folder. From there, the game should be able to run! This exact output will be what you run on Linux and Windows. The only difference will be the native libraries in addition to FNA.dll.config , which should be in your output folder even if you're on Windows. FNA.dll.config is what remaps the native DLL names to the proper names of the native libraries on non-Windows operating systems. Aside from this, everything else should work - the C# assemblies, the Content, everything. Push this output to a Linux box and try them out! When using a developer environment on macOS, you will want to add an environment variable that sets DYLD_LIBRARY_PATH=./osx/ , so that the IDE's runtime environment will find the fnalibs binaries.","title":"4. Running the FNA Output"},{"location":"2b%3A-Building-New-Games-with-FNA/","text":"2b: Building New Games with FNA Before You Start This is strictly a tutorial about using FNA. It is NOT a C# tutorial! If you are learning C# for the first time, use Microsoft's official Introduction to C# on MSDN first before continuing on. Also, be sure to finish Page 1 before starting this page! What is XNA? XNA was, at its core, the software equivalent of an 80's Saturday morning cartoon based on a toy line: A massive advertisement masquerading as a real product. It was built to advertise many new (at the time) products in development at Microsoft: C# 2.0 Direct3D Effects Framework XACT Audio Creation Tool XInput and the Xbox 360 Controller Xbox 360 + Windows Media Center From 2006 to 2010, Microsoft maintained XNA as a means of allowing independent game developers to ship small games written in C# on Xbox 360, via the \"Xbox Live Indie Games\" marketplace. The final XNA release also supported building for Windows Phone 7 devices. As for the XNA API, it was largely a C# wrapper for various DirectX components, but not quite all of them - many features are unavailable in favor of the aforementioned new-fangled DirectX products. For example, while there is a GraphicsDevice class that effectively acts as a 1:1 map of ID3D10Device , notably missing is support for low-level shaders and constant buffers; instead you are expected to use Effects for shader support. XNA was officially discontinued in 2012, and the Xbox Live Indie Games marketplace was shut down on November 2017. What is FNA? FNA is a preservation project designed to accurately reimplement the XNA runtime libraries. When you have an XNA game, you should be able to take the source, compile it against FNA, and have a fully-functioning port. At its core, FNA is a portability library, but many continue to develop new games with FNA. This tutorial will help you make your own FNA games, without needing XNA as a prerequisite. If you are bringing an existing XNA game to FNA, follow this wiki page instead. Your First Game See Page 1 for a quick refresher on making new projects. Once you have a project made, you can then proceed: The First Program This is the smallest possible program using the framework portion of XNA: using System; using Microsoft.Xna.Framework; static class Program { [STAThread] static void Main(string[] args) { using (Game g = new Game()) { new GraphicsDeviceManager(g); g.Run(); } } } This should compile into a folder like bin/Debug/ . Next to your executable, you will put the native libraries you downloaded earlier into this folder. You only need to worry about the libraries for your development platform; the rest will be for when you distribute your game . For example, if you're building an AnyCPU program on Windows x64, you would take the contents of the native library archive's x64 folder and put them next to your exe. When using a developer environment on macOS, you will want to add an environment variable that sets DYLD_LIBRARY_PATH=./osx/ (or wherever your dylib files are), so that the IDE's runtime environment will find the fnalibs binaries. When running this program, you might see some random trash in the window; that is most likely old graphics memory from another program you were running. Aside from that, the game is fully functional; it is reading input, running updates, and presenting frames to the window. But if this is the whole program, where do we put the rest of the game? The First Game Object The trick is that you're not going to create a Game directly. Instead, you're going to inherit it! using System; using Microsoft.Xna.Framework; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private FNAGame() { // This gets assigned to something internally, don't worry... new GraphicsDeviceManager(this); } } But again, there's still no place to put the game. That's because Game has several protected methods that you are meant to implement. Here's what it looks like with the most commonly-used methods: using System; using Microsoft.Xna.Framework; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private FNAGame() { GraphicsDeviceManager gdm = new GraphicsDeviceManager(this); // Typically you would load a config here... gdm.PreferredBackBufferWidth = 1280; gdm.PreferredBackBufferHeight = 720; gdm.IsFullScreen = false; gdm.SynchronizeWithVerticalRetrace = true; } protected override void Initialize() { /* This is a nice place to start up the engine, after * loading configuration stuff in the constructor */ base.Initialize(); } protected override void LoadContent() { // Load textures, sounds, and so on in here... base.LoadContent(); } protected override void UnloadContent() { // Clean up after yourself! base.UnloadContent(); } protected override void Update(GameTime gameTime) { // Run game logic in here. Do NOT render anything here! base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Render stuff in here. Do NOT run game logic in here! GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } The First Input It's not a game without input, right? FNA exposes GamePad , Keyboard , and Mouse for user input. There is also a Microsoft.Xna.Framework.Input.Touch namespace for touch screen support. Input isn't terribly complicated; you store two copies of input state, one for current input and another for previous input. This lets you detect presses and releases, in addition to just checking for a button being down: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private KeyboardState keyboardPrev = new KeyboardState(); private MouseState mousePrev = new MouseState(); private GamePadState gpPrev = new GamePadState(); private FNAGame() { new GraphicsDeviceManager(this); } protected override void Update(GameTime gameTime) { // Poll input KeyboardState keyboardCur = Keyboard.GetState(); MouseState mouseCur = Mouse.GetState(); GamePadState gpCur = GamePad.GetState(PlayerIndex.One); // Check for presses if (keyboardCur.IsKeyDown(Keys.Space) && keyboardPrev.IsKeyUp(Keys.Space)) { System.Console.WriteLine(\"Space bar was pressed!\"); } if (mouseCur.RightButton == ButtonState.Released && mousePrev.RightButton == ButtonState.Pressed) { System.Console.WriteLine(\"Right mouse button was released!\"); } if (gpCur.Buttons.A == ButtonState.Pressed && gpPrev.Buttons.A == ButtonState.Pressed) { System.Console.WriteLine(\"A button is being held!\"); } // Current is now previous! keyboardPrev = keyboardCur; mousePrev = mouseCur; gpPrev = gpCur; base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } Be sure to read all of the input APIs for more details! You may also be interested in some extensions to the XNA spec that improve input support in FNA. The First Sprite Finally, some graphics! In XNA, there is a class called SpriteBatch that makes sprite drawing relatively easy. Combine that with your own textures and you have the foundation of a 2D renderer. This sample loads a PNG named \"FNATexture\", located in a \"Content\" folder, and renders it with a SpriteBatch: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private SpriteBatch batch; private Texture2D texture; private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Create the batch... batch = new SpriteBatch(GraphicsDevice); // ... then load a texture from ./Content/FNATexture.png texture = Content.Load<Texture2D>(\"FNATexture\"); } protected override void UnloadContent() { batch.Dispose(); texture.Dispose(); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // Draw the texture to the corner of the screen batch.Begin(); batch.Draw(texture, Vector2.Zero, Color.White); batch.End(); base.Draw(gameTime); } } If all went well, the PNG you chose should now be displayed! When drawing sprites, be absolutely sure that you draw as many as you possibly can before calling End() ; batches are meant to be large, singular groups rather than lots of small, fragmented groups. The more you put in a single batch, the better your program will perform. And whatever you do, do NOT use SpriteSortMode.Immediate ! The First Sound In addition to XACT, there is also a SoundEffect API available. It's as simple as loading a .wav file and mashing Play() : using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Input; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private SoundEffect sound; private KeyboardState keyboardPrev = new KeyboardState(); private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Sound is ./Content/FNASound.wav sound = Content.Load<SoundEffect>(\"FNASound\"); } protected override void UnloadContent() { sound.Dispose(); } protected override void Update(GameTime gameTime) { KeyboardState keyboardCur = Keyboard.GetState(); if (keyboardCur.IsKeyDown(Keys.Space) && keyboardPrev.IsKeyUp(Keys.Space)) { sound.Play(); } keyboardPrev = keyboardCur; } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } There is lots of deeper functionality, including instance management, 3D audio APIs, and even a streaming sound object, useful for streaming from larger files (for example, sending decoded data from an Ogg Vorbis music file). The First Song XNA includes a Media namespace, which includes support for basic playback of music and video files. FNA supports Ogg Vorbis and QOA for the Song implementation: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Media; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private Song song; private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Song is ./Content/FNASong.ogg song = Content.Load<Song>(\"FNASong\"); } protected override void UnloadContent() { song.Dispose(); } protected override void Update(GameTime gameTime) { // Just keep playing the song over and over if (MediaPlayer.State == MediaState.Stopped) { MediaPlayer.Play(song); } base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } The First Video Video objects are a fair bit more involved than Song . In addition to playing the sound, a VideoPlayer will provide the frames in the form of a texture, which you can then render however you like: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Media; using Microsoft.Xna.Framework.Graphics; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private GraphicsDeviceManager gdm; private Video video; private VideoPlayer videoPlayer; private SpriteBatch batch; private FNAGame() { gdm = new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Video is ./Content/FNAVideo.ogv video = Content.Load<Video>(\"FNAVideo\"); batch = new SpriteBatch(GraphicsDevice); gdm.PreferredBackBufferWidth = video.Width; gdm.PreferredBackBufferHeight = video.Height; gdm.ApplyChanges(); // Just loop the video over and over videoPlayer = new VideoPlayer(); videoPlayer.IsLooped = true; videoPlayer.Play(video); } protected override void UnloadContent() { batch.Dispose(); videoPlayer.Dispose(); video = null; } protected override void Draw(GameTime gameTime) { // Draw the video frame to the window, which should be the same size batch.Begin(SpriteSortMode.Deferred, BlendState.Opaque); batch.Draw(videoPlayer.GetTexture(), Vector2.Zero, Color.White); batch.End(); base.Draw(gameTime); } } The First Save XNA provides two filesystem APIs: TitleContainer and StorageContainer . TitleContainer is how you should open files in the game folder (provided Content.Load() does not do what you want), and is pretty much exactly the same as File.OpenRead . StorageContainer is a lot more involved, however: using System; using Microsoft.Xna.Framework.Storage; void DoStorageContainerThing() { IAsyncResult result; result = StorageDevice.BeginShowSelector(null, null); while (!result.IsCompleted) { // Just hang out for a bit... System.Threading.Thread.Sleep(1); } StorageDevice device = StorageDevice.EndShowSelector(result); result = device.BeginOpenContainer(\"SaveData\", null, null); while (!result.IsCompleted) { // Just hang out for a bit... System.Threading.Thread.Sleep(1); } StorageContainer container = device.EndOpenContainer(result); // Do stuff! // Clean up after yourself! Maybe keep `device` from getting collected. container.Dispose(); } From there, container 's API is self-explanatory. There are Create/Delete/Exists/Open/GetNames APIs for directories and files. Pretty much what you'd expect! The container's path is $SAVELOC/$CONTAINERNAME/$PLAYERINDEX : $SAVELOC looks something like this... and before you ask, yes, XNA really based the save folder on the EXE name: string platform = SDL.SDL_GetPlatform(); string exeName = Path.GetFileNameWithoutExtension( AppDomain.CurrentDomain.FriendlyName ).Replace(\".vshost\", \"\"); if (platform.Equals(\"Windows\")) { return Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.MyDocuments ), \"SavedGames\", exeName ); } if (platform.Equals(\"Mac OS X\")) { string osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } return Path.Combine( osConfigDir, \"Library/Application Support\", exeName ); } if ( platform.Equals(\"Linux\") || platform.Equals(\"FreeBSD\") || platform.Equals(\"OpenBSD\") || platform.Equals(\"NetBSD\") ) { string osConfigDir = Environment.GetEnvironmentVariable(\"XDG_DATA_HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/.local/share\"; } return Path.Combine(osConfigDir, exeName); } return SDL.SDL_GetPrefPath(null, exeName); $CONTAINERNAME is the name you passed to BeginOpenContainer . $PLAYERINDEX is either AllPlayers if you didn't pass a PlayerIndex, or Player1 through Player4 . The First Effect NOTE: This is an advanced subject! You may want to read the official Effects documentation first. XNA and FNA use Direct3D Effects for shader support. Effects are groups of HLSL shaders bundled together into one file, which can be executed in separate subgroups called \"techniques\" and \"passes\". The XNA API is slightly dumbed down compared to the stock Effects API: using Microsoft.Xna.Framework.Graphics; // Effects can be loaded as content! Effect effect = Content.Load<Effect>(\"FNAEffect\"); // You can set parameters... effect.Parameters[\"MadeUpParameter\"].SetValue(0.0f); // Set techniques... effect.CurrentTechnique = effect.Techniques[\"MadeUpTechnique\"]; // ... and then render each pass in the technique! foreach (EffectPass p in effect.CurrentTechnique.Passes) { p.Apply(); // Sets the shaders, passes the parameters GraphicsDevice.DrawIndexedPrimitives(...); } // Clean up after yourself! effect.Dispose(); XNA has multiple effects built in, for those who just want basic rendering without having to write shaders. Examples include BasicEffect , AlphaTestEffect , and EnvironmentMapEffect . When writing your own Effects, you must precompile them first. This is done with FXC , the Microsoft DirectX Shader Compiler, which you can find in the DirectX SDK . To compile .fx files: fxc.exe /T fx_2_0 FNAEffect.fx /Fo FNAEffect.fxb Note that FXC works with Wine, so on Linux and macOS you can still develop shaders by calling wine fxc.exe . To see some examples of .fx files, look at the stock effects !","title":"2b: Building New Games with FNA"},{"location":"2b%3A-Building-New-Games-with-FNA/#2b-building-new-games-with-fna","text":"","title":"2b: Building New Games with FNA"},{"location":"2b%3A-Building-New-Games-with-FNA/#before-you-start","text":"This is strictly a tutorial about using FNA. It is NOT a C# tutorial! If you are learning C# for the first time, use Microsoft's official Introduction to C# on MSDN first before continuing on. Also, be sure to finish Page 1 before starting this page!","title":"Before You Start"},{"location":"2b%3A-Building-New-Games-with-FNA/#what-is-xna","text":"XNA was, at its core, the software equivalent of an 80's Saturday morning cartoon based on a toy line: A massive advertisement masquerading as a real product. It was built to advertise many new (at the time) products in development at Microsoft: C# 2.0 Direct3D Effects Framework XACT Audio Creation Tool XInput and the Xbox 360 Controller Xbox 360 + Windows Media Center From 2006 to 2010, Microsoft maintained XNA as a means of allowing independent game developers to ship small games written in C# on Xbox 360, via the \"Xbox Live Indie Games\" marketplace. The final XNA release also supported building for Windows Phone 7 devices. As for the XNA API, it was largely a C# wrapper for various DirectX components, but not quite all of them - many features are unavailable in favor of the aforementioned new-fangled DirectX products. For example, while there is a GraphicsDevice class that effectively acts as a 1:1 map of ID3D10Device , notably missing is support for low-level shaders and constant buffers; instead you are expected to use Effects for shader support. XNA was officially discontinued in 2012, and the Xbox Live Indie Games marketplace was shut down on November 2017.","title":"What is XNA?"},{"location":"2b%3A-Building-New-Games-with-FNA/#what-is-fna","text":"FNA is a preservation project designed to accurately reimplement the XNA runtime libraries. When you have an XNA game, you should be able to take the source, compile it against FNA, and have a fully-functioning port. At its core, FNA is a portability library, but many continue to develop new games with FNA. This tutorial will help you make your own FNA games, without needing XNA as a prerequisite. If you are bringing an existing XNA game to FNA, follow this wiki page instead.","title":"What is FNA?"},{"location":"2b%3A-Building-New-Games-with-FNA/#your-first-game","text":"See Page 1 for a quick refresher on making new projects. Once you have a project made, you can then proceed:","title":"Your First Game"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-program","text":"This is the smallest possible program using the framework portion of XNA: using System; using Microsoft.Xna.Framework; static class Program { [STAThread] static void Main(string[] args) { using (Game g = new Game()) { new GraphicsDeviceManager(g); g.Run(); } } } This should compile into a folder like bin/Debug/ . Next to your executable, you will put the native libraries you downloaded earlier into this folder. You only need to worry about the libraries for your development platform; the rest will be for when you distribute your game . For example, if you're building an AnyCPU program on Windows x64, you would take the contents of the native library archive's x64 folder and put them next to your exe. When using a developer environment on macOS, you will want to add an environment variable that sets DYLD_LIBRARY_PATH=./osx/ (or wherever your dylib files are), so that the IDE's runtime environment will find the fnalibs binaries. When running this program, you might see some random trash in the window; that is most likely old graphics memory from another program you were running. Aside from that, the game is fully functional; it is reading input, running updates, and presenting frames to the window. But if this is the whole program, where do we put the rest of the game?","title":"The First Program"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-game-object","text":"The trick is that you're not going to create a Game directly. Instead, you're going to inherit it! using System; using Microsoft.Xna.Framework; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private FNAGame() { // This gets assigned to something internally, don't worry... new GraphicsDeviceManager(this); } } But again, there's still no place to put the game. That's because Game has several protected methods that you are meant to implement. Here's what it looks like with the most commonly-used methods: using System; using Microsoft.Xna.Framework; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private FNAGame() { GraphicsDeviceManager gdm = new GraphicsDeviceManager(this); // Typically you would load a config here... gdm.PreferredBackBufferWidth = 1280; gdm.PreferredBackBufferHeight = 720; gdm.IsFullScreen = false; gdm.SynchronizeWithVerticalRetrace = true; } protected override void Initialize() { /* This is a nice place to start up the engine, after * loading configuration stuff in the constructor */ base.Initialize(); } protected override void LoadContent() { // Load textures, sounds, and so on in here... base.LoadContent(); } protected override void UnloadContent() { // Clean up after yourself! base.UnloadContent(); } protected override void Update(GameTime gameTime) { // Run game logic in here. Do NOT render anything here! base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Render stuff in here. Do NOT run game logic in here! GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } }","title":"The First Game Object"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-input","text":"It's not a game without input, right? FNA exposes GamePad , Keyboard , and Mouse for user input. There is also a Microsoft.Xna.Framework.Input.Touch namespace for touch screen support. Input isn't terribly complicated; you store two copies of input state, one for current input and another for previous input. This lets you detect presses and releases, in addition to just checking for a button being down: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private KeyboardState keyboardPrev = new KeyboardState(); private MouseState mousePrev = new MouseState(); private GamePadState gpPrev = new GamePadState(); private FNAGame() { new GraphicsDeviceManager(this); } protected override void Update(GameTime gameTime) { // Poll input KeyboardState keyboardCur = Keyboard.GetState(); MouseState mouseCur = Mouse.GetState(); GamePadState gpCur = GamePad.GetState(PlayerIndex.One); // Check for presses if (keyboardCur.IsKeyDown(Keys.Space) && keyboardPrev.IsKeyUp(Keys.Space)) { System.Console.WriteLine(\"Space bar was pressed!\"); } if (mouseCur.RightButton == ButtonState.Released && mousePrev.RightButton == ButtonState.Pressed) { System.Console.WriteLine(\"Right mouse button was released!\"); } if (gpCur.Buttons.A == ButtonState.Pressed && gpPrev.Buttons.A == ButtonState.Pressed) { System.Console.WriteLine(\"A button is being held!\"); } // Current is now previous! keyboardPrev = keyboardCur; mousePrev = mouseCur; gpPrev = gpCur; base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } Be sure to read all of the input APIs for more details! You may also be interested in some extensions to the XNA spec that improve input support in FNA.","title":"The First Input"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-sprite","text":"Finally, some graphics! In XNA, there is a class called SpriteBatch that makes sprite drawing relatively easy. Combine that with your own textures and you have the foundation of a 2D renderer. This sample loads a PNG named \"FNATexture\", located in a \"Content\" folder, and renders it with a SpriteBatch: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private SpriteBatch batch; private Texture2D texture; private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Create the batch... batch = new SpriteBatch(GraphicsDevice); // ... then load a texture from ./Content/FNATexture.png texture = Content.Load<Texture2D>(\"FNATexture\"); } protected override void UnloadContent() { batch.Dispose(); texture.Dispose(); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // Draw the texture to the corner of the screen batch.Begin(); batch.Draw(texture, Vector2.Zero, Color.White); batch.End(); base.Draw(gameTime); } } If all went well, the PNG you chose should now be displayed! When drawing sprites, be absolutely sure that you draw as many as you possibly can before calling End() ; batches are meant to be large, singular groups rather than lots of small, fragmented groups. The more you put in a single batch, the better your program will perform. And whatever you do, do NOT use SpriteSortMode.Immediate !","title":"The First Sprite"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-sound","text":"In addition to XACT, there is also a SoundEffect API available. It's as simple as loading a .wav file and mashing Play() : using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Input; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private SoundEffect sound; private KeyboardState keyboardPrev = new KeyboardState(); private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Sound is ./Content/FNASound.wav sound = Content.Load<SoundEffect>(\"FNASound\"); } protected override void UnloadContent() { sound.Dispose(); } protected override void Update(GameTime gameTime) { KeyboardState keyboardCur = Keyboard.GetState(); if (keyboardCur.IsKeyDown(Keys.Space) && keyboardPrev.IsKeyUp(Keys.Space)) { sound.Play(); } keyboardPrev = keyboardCur; } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } There is lots of deeper functionality, including instance management, 3D audio APIs, and even a streaming sound object, useful for streaming from larger files (for example, sending decoded data from an Ogg Vorbis music file).","title":"The First Sound"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-song","text":"XNA includes a Media namespace, which includes support for basic playback of music and video files. FNA supports Ogg Vorbis and QOA for the Song implementation: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Media; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private Song song; private FNAGame() { new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Song is ./Content/FNASong.ogg song = Content.Load<Song>(\"FNASong\"); } protected override void UnloadContent() { song.Dispose(); } protected override void Update(GameTime gameTime) { // Just keep playing the song over and over if (MediaPlayer.State == MediaState.Stopped) { MediaPlayer.Play(song); } base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } }","title":"The First Song"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-video","text":"Video objects are a fair bit more involved than Song . In addition to playing the sound, a VideoPlayer will provide the frames in the form of a texture, which you can then render however you like: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Media; using Microsoft.Xna.Framework.Graphics; class FNAGame : Game { [STAThread] static void Main(string[] args) { using (FNAGame g = new FNAGame()) { g.Run(); } } private GraphicsDeviceManager gdm; private Video video; private VideoPlayer videoPlayer; private SpriteBatch batch; private FNAGame() { gdm = new GraphicsDeviceManager(this); // All content loaded will be in a \"Content\" folder Content.RootDirectory = \"Content\"; } protected override void LoadContent() { // Video is ./Content/FNAVideo.ogv video = Content.Load<Video>(\"FNAVideo\"); batch = new SpriteBatch(GraphicsDevice); gdm.PreferredBackBufferWidth = video.Width; gdm.PreferredBackBufferHeight = video.Height; gdm.ApplyChanges(); // Just loop the video over and over videoPlayer = new VideoPlayer(); videoPlayer.IsLooped = true; videoPlayer.Play(video); } protected override void UnloadContent() { batch.Dispose(); videoPlayer.Dispose(); video = null; } protected override void Draw(GameTime gameTime) { // Draw the video frame to the window, which should be the same size batch.Begin(SpriteSortMode.Deferred, BlendState.Opaque); batch.Draw(videoPlayer.GetTexture(), Vector2.Zero, Color.White); batch.End(); base.Draw(gameTime); } }","title":"The First Video"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-save","text":"XNA provides two filesystem APIs: TitleContainer and StorageContainer . TitleContainer is how you should open files in the game folder (provided Content.Load() does not do what you want), and is pretty much exactly the same as File.OpenRead . StorageContainer is a lot more involved, however: using System; using Microsoft.Xna.Framework.Storage; void DoStorageContainerThing() { IAsyncResult result; result = StorageDevice.BeginShowSelector(null, null); while (!result.IsCompleted) { // Just hang out for a bit... System.Threading.Thread.Sleep(1); } StorageDevice device = StorageDevice.EndShowSelector(result); result = device.BeginOpenContainer(\"SaveData\", null, null); while (!result.IsCompleted) { // Just hang out for a bit... System.Threading.Thread.Sleep(1); } StorageContainer container = device.EndOpenContainer(result); // Do stuff! // Clean up after yourself! Maybe keep `device` from getting collected. container.Dispose(); } From there, container 's API is self-explanatory. There are Create/Delete/Exists/Open/GetNames APIs for directories and files. Pretty much what you'd expect! The container's path is $SAVELOC/$CONTAINERNAME/$PLAYERINDEX : $SAVELOC looks something like this... and before you ask, yes, XNA really based the save folder on the EXE name: string platform = SDL.SDL_GetPlatform(); string exeName = Path.GetFileNameWithoutExtension( AppDomain.CurrentDomain.FriendlyName ).Replace(\".vshost\", \"\"); if (platform.Equals(\"Windows\")) { return Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.MyDocuments ), \"SavedGames\", exeName ); } if (platform.Equals(\"Mac OS X\")) { string osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } return Path.Combine( osConfigDir, \"Library/Application Support\", exeName ); } if ( platform.Equals(\"Linux\") || platform.Equals(\"FreeBSD\") || platform.Equals(\"OpenBSD\") || platform.Equals(\"NetBSD\") ) { string osConfigDir = Environment.GetEnvironmentVariable(\"XDG_DATA_HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/.local/share\"; } return Path.Combine(osConfigDir, exeName); } return SDL.SDL_GetPrefPath(null, exeName); $CONTAINERNAME is the name you passed to BeginOpenContainer . $PLAYERINDEX is either AllPlayers if you didn't pass a PlayerIndex, or Player1 through Player4 .","title":"The First Save"},{"location":"2b%3A-Building-New-Games-with-FNA/#the-first-effect","text":"NOTE: This is an advanced subject! You may want to read the official Effects documentation first. XNA and FNA use Direct3D Effects for shader support. Effects are groups of HLSL shaders bundled together into one file, which can be executed in separate subgroups called \"techniques\" and \"passes\". The XNA API is slightly dumbed down compared to the stock Effects API: using Microsoft.Xna.Framework.Graphics; // Effects can be loaded as content! Effect effect = Content.Load<Effect>(\"FNAEffect\"); // You can set parameters... effect.Parameters[\"MadeUpParameter\"].SetValue(0.0f); // Set techniques... effect.CurrentTechnique = effect.Techniques[\"MadeUpTechnique\"]; // ... and then render each pass in the technique! foreach (EffectPass p in effect.CurrentTechnique.Passes) { p.Apply(); // Sets the shaders, passes the parameters GraphicsDevice.DrawIndexedPrimitives(...); } // Clean up after yourself! effect.Dispose(); XNA has multiple effects built in, for those who just want basic rendering without having to write shaders. Examples include BasicEffect , AlphaTestEffect , and EnvironmentMapEffect . When writing your own Effects, you must precompile them first. This is done with FXC , the Microsoft DirectX Shader Compiler, which you can find in the DirectX SDK . To compile .fx files: fxc.exe /T fx_2_0 FNAEffect.fx /Fo FNAEffect.fxb Note that FXC works with Wine, so on Linux and macOS you can still develop shaders by calling wine fxc.exe . To see some examples of .fx files, look at the stock effects !","title":"The First Effect"},{"location":"3%3A-Distributing-FNA-Games/","text":"3: Distributing FNA Games At some point you will likely want to ship your FNA game to customers, so here's a guide to shipping your game in a way that is hassle-free for players. Note that this guide is for .NET Framework and Mono applications - for those using .NET 8, refer to the .NET Core section of this page. Overall System Requirements While we can't automatically determine CPU/RAM/Storage requirements (that's up to you!), we can provide a reasonably accurate requirement list for the following specs: Windows: OS: Windows 7, fully updated Graphics (Minimum): Direct3D 11 support (feature level 10_0) Graphics (Recommended): Vulkan support Linux: OS: glibc 2.31+, 64-bit only Graphics (Minimum): OpenGL 3.0+ support (2.1 with ARB extensions acceptable) Graphics (Recommended): Vulkan support Other: SDL_GameController devices fully supported Windows Because you're no longer shipping with XNA, you no longer need to provide the XNA4 redist package. Additionally, as of the latest SDL revision, we no longer require the DirectX redist to run correctly. However, as you might expect, you still need to include the appropriate .NET Framework installer. Match the version that you're targeting in VS and you're good to go. The native libraries needed by FNA are in the fnalibs.zip package under the x86/ folder. The x64/ folder will only apply if you add 64-bit support to your Windows version. GNU/Linux Download the latest version of MonoKickstart from CI . You care mostly about the \"Linux-x86_64\" artifact; the BCL and MonoPosixHelper artifacts are optional. In the main archive you will notice the following: kick.bin.x86_64 , monoconfig , monomachineconfig Lots and lots of DLL files. If you don't know which ones you need, just use them all. What you're going to do is place the game itself into the same folder as these Kick/DLL files, and you're also going to put the lib64/ folder (NOT ITS CONTENTS) from the fnalibs.zip package next to your game files. Any other native libaries you have will also go into the lib64/ folder (for example, if you're using Steamworks.NET, you would put libsteam_api.so in that folder). These files you're looking at are a highly compacted Mono runtime that will be executing the C# assemblies, just as .NET would on Windows. The upside is, there are no system dependencies - the whole runtime is in this one folder, and all the native dependencies are in the lib folder. Convenient! However, note that not every single DLL in the C# standard library exists in this folder. Libs like System.Web.Services are not provided by default to save disk space, but if you need these you can grab them from the BCL archive. kick.bin.x86_64 is going to be renamed to the name of your main EXE file. For example: flibitGame.exe flibitGame.bin.x86_64 You can optionally name it just flibitGame with no extension, if you prefer that for whatever reason. Once this is finished, you are ready to upload via SteamPipe , butler , or the GOG Galaxy builder . Steam Deck Remote Debugging Using Visual Studio Code and the above packaging process, it's actually possible to attach to a Steam Deck for remote C# debugging! The process is as follows: Set up the Steam Deck devkit and upload your game, complete with debug symbols (see Valve's documentation , you can ignore anything involving Proton as it's not used here!) On the Deck, go to your new devkit game and click \u2699\ufe0f -> Properties Under Shortcut -> Launch Options , enter the following excruciatingly long text: MONO_BUNDLED_OPTIONS='--debugger-agent=address=0.0.0.0:55555,transport=dt_socket,server=y --debug=mdb-optimizations' %command% We're hoping to streamline this step and have sent a patch to Valve for review . Add a task in launch.json to connect to the Deck debug server: { \"name\": \"Attach to Deck\", \"type\": \"mono\", \"request\": \"attach\", \"address\": \"192.168.1.yoursteamdeckIP\", \"port\": 55555 } Launch the game and start the debugger, enjoy! Single-Assembly Portability and Steam When leveraging FNA's single-assembly portability, you can run a single binary on both Windows and Linux. For distribution, you still have to make two separate packages of roughly the same game. With Steam, however, there is a way to optimize this. If you architect your depots in the following manner... Depot 4206901 - Shared Content, Windows + SteamOS + Linux Depot 4206902 - Windows Depot, Windows Depot 4206903 - Linux Depot, SteamOS + Linux The idea is that you upload the Windows fnalibs to the second depot, the Linux fnalibs and MonoKickstart environment to the third depot, then upload the entire rest of the game to the first depot. You can also put OS-specific binaries in their appropriate folders, if applicable (C# Steamworks wrappers like Steamworks.NET and Facepunch.Steamworks are the only example these days, but who knows). Because the folder layout is identical between the two, this means you can limit your upload process to a single depot, only updating the other two depots when updating FNA specifically. This dramatically reduces the workload and also reduces the chance for version sync issues! Sadly this only applies to Steam; itch and GOG do not have this feature. A good publicly-available example of this layout is the PC version of I MAED A GAM3 W1TH Z0MB1ES 1NIT!!!1 . .NET Core The above guide works for .NET Framework and Mono applications, but does not work with .NET 8. The publishing system for modern .NET has completely changed and is described below. dotnet publish -r <win-x64/linux-x64> -c Release --self-contained will produce the executable package, but each platform has different requirements for where the fnalibs must be placed. Windows: Place the x64 fnalibs in the publish directory alongside your executable. Linux: Place the lib64 fnalibs in the publish directory, in a sub-directory called netcoredeps . Single-File Applications The above steps for publishing will produce a publish directory with an absolutely enormous amount of DLLs. If you want to build a single-file executable instead, just add this to a property group in your .csproj: <PublishSingleFile>true</PublishSingleFile> However, if you do this, we request that you make an exception for FNA.dll so that it is not bundled into the exe like the rest of the app. This is not required, but it is beneficial for both end users and FNA developers, since it allows for dynamically swapping out the FNA.dll in the game's files (for debugging, modding, etc.). You can prevent FNA.dll from being bundled by changing the FNA ProjectReference in your game's .csproj to the following: <ItemGroup> <ProjectReference Include=\"path/to/FNA.Core.csproj\"> <ExcludeFromSingleFile>true</ExcludeFromSingleFile> </ProjectReference> </ItemGroup> On a similar note, please do not bundle the native fnalibs into the single-file executable, for the same reasons. (Don't worry, this will not happen unless you go out of your way to explicitly include them in the project.)","title":"3: Distributing FNA Games"},{"location":"3%3A-Distributing-FNA-Games/#3-distributing-fna-games","text":"At some point you will likely want to ship your FNA game to customers, so here's a guide to shipping your game in a way that is hassle-free for players. Note that this guide is for .NET Framework and Mono applications - for those using .NET 8, refer to the .NET Core section of this page.","title":"3: Distributing FNA Games"},{"location":"3%3A-Distributing-FNA-Games/#overall-system-requirements","text":"While we can't automatically determine CPU/RAM/Storage requirements (that's up to you!), we can provide a reasonably accurate requirement list for the following specs: Windows: OS: Windows 7, fully updated Graphics (Minimum): Direct3D 11 support (feature level 10_0) Graphics (Recommended): Vulkan support Linux: OS: glibc 2.31+, 64-bit only Graphics (Minimum): OpenGL 3.0+ support (2.1 with ARB extensions acceptable) Graphics (Recommended): Vulkan support Other: SDL_GameController devices fully supported","title":"Overall System Requirements"},{"location":"3%3A-Distributing-FNA-Games/#windows","text":"Because you're no longer shipping with XNA, you no longer need to provide the XNA4 redist package. Additionally, as of the latest SDL revision, we no longer require the DirectX redist to run correctly. However, as you might expect, you still need to include the appropriate .NET Framework installer. Match the version that you're targeting in VS and you're good to go. The native libraries needed by FNA are in the fnalibs.zip package under the x86/ folder. The x64/ folder will only apply if you add 64-bit support to your Windows version.","title":"Windows"},{"location":"3%3A-Distributing-FNA-Games/#gnulinux","text":"Download the latest version of MonoKickstart from CI . You care mostly about the \"Linux-x86_64\" artifact; the BCL and MonoPosixHelper artifacts are optional. In the main archive you will notice the following: kick.bin.x86_64 , monoconfig , monomachineconfig Lots and lots of DLL files. If you don't know which ones you need, just use them all. What you're going to do is place the game itself into the same folder as these Kick/DLL files, and you're also going to put the lib64/ folder (NOT ITS CONTENTS) from the fnalibs.zip package next to your game files. Any other native libaries you have will also go into the lib64/ folder (for example, if you're using Steamworks.NET, you would put libsteam_api.so in that folder). These files you're looking at are a highly compacted Mono runtime that will be executing the C# assemblies, just as .NET would on Windows. The upside is, there are no system dependencies - the whole runtime is in this one folder, and all the native dependencies are in the lib folder. Convenient! However, note that not every single DLL in the C# standard library exists in this folder. Libs like System.Web.Services are not provided by default to save disk space, but if you need these you can grab them from the BCL archive. kick.bin.x86_64 is going to be renamed to the name of your main EXE file. For example: flibitGame.exe flibitGame.bin.x86_64 You can optionally name it just flibitGame with no extension, if you prefer that for whatever reason. Once this is finished, you are ready to upload via SteamPipe , butler , or the GOG Galaxy builder .","title":"GNU/Linux"},{"location":"3%3A-Distributing-FNA-Games/#steam-deck-remote-debugging","text":"Using Visual Studio Code and the above packaging process, it's actually possible to attach to a Steam Deck for remote C# debugging! The process is as follows: Set up the Steam Deck devkit and upload your game, complete with debug symbols (see Valve's documentation , you can ignore anything involving Proton as it's not used here!) On the Deck, go to your new devkit game and click \u2699\ufe0f -> Properties Under Shortcut -> Launch Options , enter the following excruciatingly long text: MONO_BUNDLED_OPTIONS='--debugger-agent=address=0.0.0.0:55555,transport=dt_socket,server=y --debug=mdb-optimizations' %command% We're hoping to streamline this step and have sent a patch to Valve for review . Add a task in launch.json to connect to the Deck debug server: { \"name\": \"Attach to Deck\", \"type\": \"mono\", \"request\": \"attach\", \"address\": \"192.168.1.yoursteamdeckIP\", \"port\": 55555 } Launch the game and start the debugger, enjoy!","title":"Steam Deck Remote Debugging"},{"location":"3%3A-Distributing-FNA-Games/#single-assembly-portability-and-steam","text":"When leveraging FNA's single-assembly portability, you can run a single binary on both Windows and Linux. For distribution, you still have to make two separate packages of roughly the same game. With Steam, however, there is a way to optimize this. If you architect your depots in the following manner... Depot 4206901 - Shared Content, Windows + SteamOS + Linux Depot 4206902 - Windows Depot, Windows Depot 4206903 - Linux Depot, SteamOS + Linux The idea is that you upload the Windows fnalibs to the second depot, the Linux fnalibs and MonoKickstart environment to the third depot, then upload the entire rest of the game to the first depot. You can also put OS-specific binaries in their appropriate folders, if applicable (C# Steamworks wrappers like Steamworks.NET and Facepunch.Steamworks are the only example these days, but who knows). Because the folder layout is identical between the two, this means you can limit your upload process to a single depot, only updating the other two depots when updating FNA specifically. This dramatically reduces the workload and also reduces the chance for version sync issues! Sadly this only applies to Steam; itch and GOG do not have this feature. A good publicly-available example of this layout is the PC version of I MAED A GAM3 W1TH Z0MB1ES 1NIT!!!1 .","title":"Single-Assembly Portability and Steam"},{"location":"3%3A-Distributing-FNA-Games/#net-core","text":"The above guide works for .NET Framework and Mono applications, but does not work with .NET 8. The publishing system for modern .NET has completely changed and is described below. dotnet publish -r <win-x64/linux-x64> -c Release --self-contained will produce the executable package, but each platform has different requirements for where the fnalibs must be placed. Windows: Place the x64 fnalibs in the publish directory alongside your executable. Linux: Place the lib64 fnalibs in the publish directory, in a sub-directory called netcoredeps .","title":".NET Core"},{"location":"3%3A-Distributing-FNA-Games/#single-file-applications","text":"The above steps for publishing will produce a publish directory with an absolutely enormous amount of DLLs. If you want to build a single-file executable instead, just add this to a property group in your .csproj: <PublishSingleFile>true</PublishSingleFile> However, if you do this, we request that you make an exception for FNA.dll so that it is not bundled into the exe like the rest of the app. This is not required, but it is beneficial for both end users and FNA developers, since it allows for dynamically swapping out the FNA.dll in the game's files (for debugging, modding, etc.). You can prevent FNA.dll from being bundled by changing the FNA ProjectReference in your game's .csproj to the following: <ItemGroup> <ProjectReference Include=\"path/to/FNA.Core.csproj\"> <ExcludeFromSingleFile>true</ExcludeFromSingleFile> </ProjectReference> </ItemGroup> On a similar note, please do not bundle the native fnalibs into the single-file executable, for the same reasons. (Don't worry, this will not happen unless you go out of your way to explicitly include them in the project.)","title":"Single-File Applications"},{"location":"4%3A-FNA-and-Windows-API/","text":"4: FNA and Windows API While we have set out to make our XNA reimplementation as portable as possible, this work can only ever make XNA itself portable. We cannot make your game portable automatically! Here are some common things we've seen that will get in the way of making your game 100% portable: 64-bit Support DirectInput Support Filesystem Portability Environment.SpecialFolder User32, Kernel32, etc. System.Drawing System.Windows.Forms Using the FNA GameWindow in System.Windows.Forms C++/CLI Assemblies 64-bit Support Unlike XNA, FNA supports both 64-bit and AnyCPU configurations. On Linux and macOS this does not really matter, as the Mono CLR does not care what the architecture is for managed binaries and MonoKickstart automatically picks the right library folder, but on Windows each target architecture needs its own version. These days you can safely assume 64-bit only, but if you absolutely require AnyCPU (be careful, modern Visual Studio releases will still prefer 32-bit for AnyCPU builds anyway!) you should add this code to the start of your Main function: using System; using System.IO; using System.Runtime.InteropServices; ... [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool SetDefaultDllDirectories(int directoryFlags); [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] static extern void AddDllDirectory(string lpPathName); [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool SetDllDirectory(string lpPathName); const int LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000; ... static void Main(string[] args) { if (Environment.OSVersion.Platform == PlatformID.Win32NT) { try { SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS); AddDllDirectory(Path.Combine( AppDomain.CurrentDomain.BaseDirectory, Environment.Is64BitProcess ? \"x64\" : \"x86\" )); } catch { // Pre-Windows 7, KB2533623 SetDllDirectory(Path.Combine( AppDomain.CurrentDomain.BaseDirectory, Environment.Is64BitProcess ? \"x64\" : \"x86\" )); } } ... } With this you can keep the C# binaries at the top level, and the native libraries can be in x86 and x64 separately (we do this for you already in fnalibs.zip). DirectInput Support If you have a specialized DirectInput path for your XNA game, go ahead and take it out of your FNA build. FNA uses SDL_GameController for its GamePad implementation, which supports both XInput and DirectInput on Windows (and for Linux/macOS, we support the standard joystick input interfaces). Even for non-XInput controllers you can expect them to map to the 360 layout provided by GamePad; SDL_GameController pulls in configurations from its own internal database as well as the Steam Big Picture Mode database to automap any known joystick to the 360 layout. Additionally, FNA checks for gamecontrollerdb.txt in the game's root folder so that developers and customers without access to the other databases may add their own configurations as well. Lastly, our implementation is far more flexible - we support numerous extensions and environment variables to allow modernized input support, including vendor/product detection, higher player counts, motion controls, etc. For more information, see the SDL_GameController documentation . Filesystem Portability Here are three things you may get hit by when running an FNA title on Linux and macOS: Paths are separated with / , NOT with \\ ! We do what we can to accommodate this in FNA, but you should not depend on us saving you here! On Linux, filenames are case-sensitive! For example, fileName is NOT the same as Filename ! There are no drive letters on Unix-like operating systems. For example, while a user folder on Windows is typically C:\\Users\\flibitijibibo\\ , on Linux it's typically /home/flibitijibibo/ , and on macOS it's /Users/flibitijibibo/ . There exists an environment variable called MONO_IOMAP that can attempt to resolve these for you, but you should not depend on this feature, as it is neither guaranteed to work nor is it performant! Your I/O performance can get hit by this! The solution is to just check your code to be sure that you do not depend on any Windows-specific behavior in your code. We recommend changing your code rather than your content's filenames, as that will retain consistency across all platforms without, say, having to worry about platform content folders X and Y when rebuilding your content. It's confusing and it probably won't work if you deploy from Windows anyway. The best thing you can do to make your file reading portable is to use TitleContainer.OpenStream instead of File.OpenRead , as this deals with both directory separators as well as special path requirements for platforms with unique filesystems (but this does NOT deal with case sensitivity!). Other helpful features in C# are Path.DirectorySeparatorChar and Path.Combine() , found in System.IO . Environment.SpecialFolder For the most part, these simply don't work correctly on Linux or macOS. Worse, PC storage is usually not applicable on consoles - more on this later. If you use StorageDevice for all your file I/O, don't worry - we take care of this for you: For Linux/*BSD, save directories are meant to go in the location specified by the XDG specification. Config files should go in $XDG_CONFIG_HOME, or ~/.config/YourApp/ . Save data should go in $XDG_DATA_HOME, or ~/.local/share/YourApp/ . For macOS, save directories are meant to go in the location required by Apple for certification. All user data should go in ~/Library/Application Support/YourApp/ . Other platforms may have their own specific needs for savedata. For unspecified platforms, consider using SDL_GetPrefPath . It is strongly recommended that you try to determine these locations at runtime, rather than with platform defs. You want to be able to leverage our single-assembly portability! Here's an example for determining the save location at runtime: using System; using System.IO; using SDL3; public const string GameName = \"flibitGame\"; public static readonly string SaveDirectory = GetSaveDirectory(); private static string GetSaveDirectory() { string platform = SDL.SDL_GetPlatform(); if (platform.Equals(\"Windows\")) { return Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.MyDocuments ), \"SavedGames\", GameName ); } else if (platform.Equals(\"macOS\")) { string osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/Library/Application Support\"; return Path.Combine(osConfigDir, GameName); } else if ( platform.Equals(\"Linux\") || platform.Equals(\"FreeBSD\") || platform.Equals(\"OpenBSD\") || platform.Equals(\"NetBSD\") ) { string osConfigDir = Environment.GetEnvironmentVariable(\"XDG_DATA_HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/.local/share\"; } return Path.Combine(osConfigDir, GameName); } else { return SDL.SDL_GetPrefPath(CompanyName, GameName); } } As mentioned previously, this is only effective on PC, and only sometimes - it is strongly recommended that you use SDL3's Storage API instead. This is safer, can improve disk I/O performance, and even works on console platforms. User32, Kernel32, etc. Some XNA games use the Windows API directly for features such as the event loop. FNA actually uses the SDL_Event loop internally, so you cannot directly replace the event loop as you would want to do with SDL_PollEvent. Instead, use SDL_AddEventWatch or SDL_SetEventFilter: https://wiki.libsdl.org/SDL_AddEventWatch https://wiki.libsdl.org/SDL_SetEventFilter When SDL pumps events, these callbacks will be called with the relevant events. For a more complete guide to the SDL API, see the SDL wiki: https://wiki.libsdl.org/APIByCategory Most (if not all) Win32 functions can be replaced with an equivalent SDL call. System.Drawing For the most part this is a harmless namespace, unless you make a call that depends on GDI+. System.Drawing.Imaging is particularly painful in this respect. The problem is that on Linux and macOS, you will need libgdiplus, which has an insane amount of dependencies, absolutely none of which you want. Sometimes you can simply replace this code with values or constants that replace the GDI-dependent values, but sometimes you may need a real replacement for things like software surface manipulation. In this case, you can use the SDL_Surface API: https://wiki.libsdl.org/CategorySurface System.Windows.Forms In many XNA games, there is frequent use of the System.Windows.Forms namespace for various operations, mostly related to window management. We strongly recommend replacing this with SDL when moving to FNA. The SDL documentation can be found here: https://wiki.libsdl.org/APIByCategory Subsystems like SDL_Video, SDL_Cursor, and SDL_Clipboard should be able to provide you with the same functionality found in System.Windows.Forms. For example, if you want to use a messagebox: #if SDL3 SDL3.SDL.SDL_ShowSimpleMessageBox( SDL3.SDL.SDL_MessageBoxFlags.SDL_MESSAGEBOX_ERROR, title, message, game.Window.Handle ); ); #else System.Windows.Forms.MessageBox.Show( message, title ); #endif Using the FNA GameWindow in System.Windows.Forms As mentioned in the previous section, you should NOT be using System.Windows.Forms when shipping an FNA game. However, if you simply want to use it for something like a developer-internal editor that's only used on Windows, there is still a way to hook the FNA window to a Form. Because the GameWindow.Handle no longer directly refers to a Win32 HWND, System.Windows.Forms code that depends on this handle will no longer work. But, there is still a way to keep most of your code here. For an example on how to use FNA's GameWindow.Handle IntPtr for System.Windows.Forms, see this example: https://gist.github.com/flibitijibibo/cf282bfccc1eaeb47550 Note that you want the window to be borderless when attaching to a Panel. To do this, you can use the GameWindow.IsBorderlessEXT extension to remove the border. C++/CLI Assemblies C++/CLI is not available in Mono, so these binaries cannot run anywhere except on Windows with .NET. The solution is to separate the C# half from the native C/C++ half, and access the native half with P/Invoke calls and native C entry points. For example: /* somelib.h */ #ifndef SOMELIB_H #define SOMELIB_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif #ifdef _WIN32 #define EXPORTFN __declspec(dllexport) #define DELEGATECALL __stdcall #else #define EXPORTFN #define DELEGATECALL #endif typedef void (DELEGATECALL *SomeCallback)(int32_t); EXPORTFN void SomeFunction(SomeCallback callback); #undef EXPORTFN #undef DELEGATECALL #ifdef __cplusplus } #endif #endif /* SOMELIB_H */ /* End somelib.h */ /* somelib.c */ #include \"somelib.h\" void SomeFunction(SomeCallback callback) { callback(1337); } /* End somelib.c */ /* SomeLib.cs */ using System.Runtime.InteropServices; public static class SomeLib { public delegate void SomeCallback(int result); [DllImport(\"somelib.dll\", CallingConvention = CallingConvenction.Cdecl)] public static extern void SomeFunction(SomeCallback callback); } /* End SomeLib.cs */","title":"4: FNA and Windows API"},{"location":"4%3A-FNA-and-Windows-API/#4-fna-and-windows-api","text":"While we have set out to make our XNA reimplementation as portable as possible, this work can only ever make XNA itself portable. We cannot make your game portable automatically! Here are some common things we've seen that will get in the way of making your game 100% portable: 64-bit Support DirectInput Support Filesystem Portability Environment.SpecialFolder User32, Kernel32, etc. System.Drawing System.Windows.Forms Using the FNA GameWindow in System.Windows.Forms C++/CLI Assemblies","title":"4: FNA and Windows API"},{"location":"4%3A-FNA-and-Windows-API/#64-bit-support","text":"Unlike XNA, FNA supports both 64-bit and AnyCPU configurations. On Linux and macOS this does not really matter, as the Mono CLR does not care what the architecture is for managed binaries and MonoKickstart automatically picks the right library folder, but on Windows each target architecture needs its own version. These days you can safely assume 64-bit only, but if you absolutely require AnyCPU (be careful, modern Visual Studio releases will still prefer 32-bit for AnyCPU builds anyway!) you should add this code to the start of your Main function: using System; using System.IO; using System.Runtime.InteropServices; ... [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool SetDefaultDllDirectories(int directoryFlags); [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] static extern void AddDllDirectory(string lpPathName); [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool SetDllDirectory(string lpPathName); const int LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000; ... static void Main(string[] args) { if (Environment.OSVersion.Platform == PlatformID.Win32NT) { try { SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS); AddDllDirectory(Path.Combine( AppDomain.CurrentDomain.BaseDirectory, Environment.Is64BitProcess ? \"x64\" : \"x86\" )); } catch { // Pre-Windows 7, KB2533623 SetDllDirectory(Path.Combine( AppDomain.CurrentDomain.BaseDirectory, Environment.Is64BitProcess ? \"x64\" : \"x86\" )); } } ... } With this you can keep the C# binaries at the top level, and the native libraries can be in x86 and x64 separately (we do this for you already in fnalibs.zip).","title":"64-bit Support"},{"location":"4%3A-FNA-and-Windows-API/#directinput-support","text":"If you have a specialized DirectInput path for your XNA game, go ahead and take it out of your FNA build. FNA uses SDL_GameController for its GamePad implementation, which supports both XInput and DirectInput on Windows (and for Linux/macOS, we support the standard joystick input interfaces). Even for non-XInput controllers you can expect them to map to the 360 layout provided by GamePad; SDL_GameController pulls in configurations from its own internal database as well as the Steam Big Picture Mode database to automap any known joystick to the 360 layout. Additionally, FNA checks for gamecontrollerdb.txt in the game's root folder so that developers and customers without access to the other databases may add their own configurations as well. Lastly, our implementation is far more flexible - we support numerous extensions and environment variables to allow modernized input support, including vendor/product detection, higher player counts, motion controls, etc. For more information, see the SDL_GameController documentation .","title":"DirectInput Support"},{"location":"4%3A-FNA-and-Windows-API/#filesystem-portability","text":"Here are three things you may get hit by when running an FNA title on Linux and macOS: Paths are separated with / , NOT with \\ ! We do what we can to accommodate this in FNA, but you should not depend on us saving you here! On Linux, filenames are case-sensitive! For example, fileName is NOT the same as Filename ! There are no drive letters on Unix-like operating systems. For example, while a user folder on Windows is typically C:\\Users\\flibitijibibo\\ , on Linux it's typically /home/flibitijibibo/ , and on macOS it's /Users/flibitijibibo/ . There exists an environment variable called MONO_IOMAP that can attempt to resolve these for you, but you should not depend on this feature, as it is neither guaranteed to work nor is it performant! Your I/O performance can get hit by this! The solution is to just check your code to be sure that you do not depend on any Windows-specific behavior in your code. We recommend changing your code rather than your content's filenames, as that will retain consistency across all platforms without, say, having to worry about platform content folders X and Y when rebuilding your content. It's confusing and it probably won't work if you deploy from Windows anyway. The best thing you can do to make your file reading portable is to use TitleContainer.OpenStream instead of File.OpenRead , as this deals with both directory separators as well as special path requirements for platforms with unique filesystems (but this does NOT deal with case sensitivity!). Other helpful features in C# are Path.DirectorySeparatorChar and Path.Combine() , found in System.IO .","title":"Filesystem Portability"},{"location":"4%3A-FNA-and-Windows-API/#environmentspecialfolder","text":"For the most part, these simply don't work correctly on Linux or macOS. Worse, PC storage is usually not applicable on consoles - more on this later. If you use StorageDevice for all your file I/O, don't worry - we take care of this for you: For Linux/*BSD, save directories are meant to go in the location specified by the XDG specification. Config files should go in $XDG_CONFIG_HOME, or ~/.config/YourApp/ . Save data should go in $XDG_DATA_HOME, or ~/.local/share/YourApp/ . For macOS, save directories are meant to go in the location required by Apple for certification. All user data should go in ~/Library/Application Support/YourApp/ . Other platforms may have their own specific needs for savedata. For unspecified platforms, consider using SDL_GetPrefPath . It is strongly recommended that you try to determine these locations at runtime, rather than with platform defs. You want to be able to leverage our single-assembly portability! Here's an example for determining the save location at runtime: using System; using System.IO; using SDL3; public const string GameName = \"flibitGame\"; public static readonly string SaveDirectory = GetSaveDirectory(); private static string GetSaveDirectory() { string platform = SDL.SDL_GetPlatform(); if (platform.Equals(\"Windows\")) { return Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.MyDocuments ), \"SavedGames\", GameName ); } else if (platform.Equals(\"macOS\")) { string osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/Library/Application Support\"; return Path.Combine(osConfigDir, GameName); } else if ( platform.Equals(\"Linux\") || platform.Equals(\"FreeBSD\") || platform.Equals(\"OpenBSD\") || platform.Equals(\"NetBSD\") ) { string osConfigDir = Environment.GetEnvironmentVariable(\"XDG_DATA_HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { osConfigDir = Environment.GetEnvironmentVariable(\"HOME\"); if (String.IsNullOrEmpty(osConfigDir)) { return \".\"; // Oh well. } osConfigDir += \"/.local/share\"; } return Path.Combine(osConfigDir, GameName); } else { return SDL.SDL_GetPrefPath(CompanyName, GameName); } } As mentioned previously, this is only effective on PC, and only sometimes - it is strongly recommended that you use SDL3's Storage API instead. This is safer, can improve disk I/O performance, and even works on console platforms.","title":"Environment.SpecialFolder"},{"location":"4%3A-FNA-and-Windows-API/#user32-kernel32-etc","text":"Some XNA games use the Windows API directly for features such as the event loop. FNA actually uses the SDL_Event loop internally, so you cannot directly replace the event loop as you would want to do with SDL_PollEvent. Instead, use SDL_AddEventWatch or SDL_SetEventFilter: https://wiki.libsdl.org/SDL_AddEventWatch https://wiki.libsdl.org/SDL_SetEventFilter When SDL pumps events, these callbacks will be called with the relevant events. For a more complete guide to the SDL API, see the SDL wiki: https://wiki.libsdl.org/APIByCategory Most (if not all) Win32 functions can be replaced with an equivalent SDL call.","title":"User32, Kernel32, etc."},{"location":"4%3A-FNA-and-Windows-API/#systemdrawing","text":"For the most part this is a harmless namespace, unless you make a call that depends on GDI+. System.Drawing.Imaging is particularly painful in this respect. The problem is that on Linux and macOS, you will need libgdiplus, which has an insane amount of dependencies, absolutely none of which you want. Sometimes you can simply replace this code with values or constants that replace the GDI-dependent values, but sometimes you may need a real replacement for things like software surface manipulation. In this case, you can use the SDL_Surface API: https://wiki.libsdl.org/CategorySurface","title":"System.Drawing"},{"location":"4%3A-FNA-and-Windows-API/#systemwindowsforms","text":"In many XNA games, there is frequent use of the System.Windows.Forms namespace for various operations, mostly related to window management. We strongly recommend replacing this with SDL when moving to FNA. The SDL documentation can be found here: https://wiki.libsdl.org/APIByCategory Subsystems like SDL_Video, SDL_Cursor, and SDL_Clipboard should be able to provide you with the same functionality found in System.Windows.Forms. For example, if you want to use a messagebox: #if SDL3 SDL3.SDL.SDL_ShowSimpleMessageBox( SDL3.SDL.SDL_MessageBoxFlags.SDL_MESSAGEBOX_ERROR, title, message, game.Window.Handle ); ); #else System.Windows.Forms.MessageBox.Show( message, title ); #endif","title":"System.Windows.Forms"},{"location":"4%3A-FNA-and-Windows-API/#using-the-fna-gamewindow-in-systemwindowsforms","text":"As mentioned in the previous section, you should NOT be using System.Windows.Forms when shipping an FNA game. However, if you simply want to use it for something like a developer-internal editor that's only used on Windows, there is still a way to hook the FNA window to a Form. Because the GameWindow.Handle no longer directly refers to a Win32 HWND, System.Windows.Forms code that depends on this handle will no longer work. But, there is still a way to keep most of your code here. For an example on how to use FNA's GameWindow.Handle IntPtr for System.Windows.Forms, see this example: https://gist.github.com/flibitijibibo/cf282bfccc1eaeb47550 Note that you want the window to be borderless when attaching to a Panel. To do this, you can use the GameWindow.IsBorderlessEXT extension to remove the border.","title":"Using the FNA GameWindow in System.Windows.Forms"},{"location":"4%3A-FNA-and-Windows-API/#ccli-assemblies","text":"C++/CLI is not available in Mono, so these binaries cannot run anywhere except on Windows with .NET. The solution is to separate the C# half from the native C/C++ half, and access the native half with P/Invoke calls and native C entry points. For example: /* somelib.h */ #ifndef SOMELIB_H #define SOMELIB_H #include <stdint.h> #ifdef __cplusplus extern \"C\" { #endif #ifdef _WIN32 #define EXPORTFN __declspec(dllexport) #define DELEGATECALL __stdcall #else #define EXPORTFN #define DELEGATECALL #endif typedef void (DELEGATECALL *SomeCallback)(int32_t); EXPORTFN void SomeFunction(SomeCallback callback); #undef EXPORTFN #undef DELEGATECALL #ifdef __cplusplus } #endif #endif /* SOMELIB_H */ /* End somelib.h */ /* somelib.c */ #include \"somelib.h\" void SomeFunction(SomeCallback callback) { callback(1337); } /* End somelib.c */ /* SomeLib.cs */ using System.Runtime.InteropServices; public static class SomeLib { public delegate void SomeCallback(int result); [DllImport(\"somelib.dll\", CallingConvention = CallingConvenction.Cdecl)] public static extern void SomeFunction(SomeCallback callback); } /* End SomeLib.cs */","title":"C++/CLI Assemblies"},{"location":"5%3A-FNA-Extensions/","text":"5: FNA Extensions FNA, in rare cases, will provide extensions to the XNA 4.0 Refresh specification in order to simplify often-unportable tasks, provide feature parity with other projects such as the MonoGame project, and so on. GamePad Extensions The GamePad extensions are unique in that there are a lot of them (our policy is generally to not extend the spec unless it's a life-or-death situation) and that they are pretty much universally recommended to use, unlike the other extensions which generally exist for very specific use cases. FNA currently has the following extensions for controller support: GetGUIDEXT public static string GetGUIDEXT(PlayerIndex playerIndex) is a new method for GamePad that allows you to get the hardware GUID for a given controller. Since GUIDs are organized differently depending on the OS, we have abstracted the GUID string into a shortened, unified format that is consistent across operating systems. To use the GetGUIDEXT extension: public MyControllerType GetControllerType(PlayerIndex index) { /* Try to only do this once on initialization! It's slow! */ string guid = GamePad.GetGUIDEXT(index); if (guid.Equals(\"4c05c405\") || guid.Equals(\"4c05cc09\")) { return MyControllerType.PS4; } if (guid.Equals(\"4c05e60c\")) { return MyControllerType.PS5; } if (guid.Equals(\"7e050920\") || guid.Equals(\"7e053003\")) { return MyControllerType.Nintendo; } return MyControllerType.Xbox; } SetLightBarEXT public static void SetLightBarEXT(PlayerIndex playerIndex, Color color) is a new method for GamePad that allows you to set the color of the light bar on the DualShock 4 and DualSense controllers. There is a matching bool HasLightBarEXT property in GamePadCapabilities . To use the SetLightBarEXT extension: public void UpdateLightBar() { if (playerIsDead) { GamePad.SetLightBarEXT(index, Color.Red); } else { GamePad.SetLightBarEXT(index, Color.Green); } } SetTriggerVibrationEXT public static bool SetTriggerVibrationEXT is a new method for GamePad that allows setting the speed of motors specifically found in the triggers - this is found in the Xbox One controller, for example. There is a matching bool HasTriggerVibrationMotorsEXT property in GamePadCapabilities . The function is used in exactly the same way as SetVibration , so wherever you have a SetVibration in your game you will probably want a SetTriggerVibrationEXT call as well, should you choose to support trigger-specific haptics. GetGyroEXT/GetAccelerometerEXT public static bool GetGyroEXT/GetAccelerometerEXT are new methods for GamePad that poll the state of a gyro in a controller, should they exist (the PS4 and Switch controllers have them, for example). There are matching bool HasGyroEXT/HasAccelerometerEXT properties in GamePadCapabilities . To use the extensions: public static void DoMotionControls() { Vector3 gyro, accel; GamePad.GetGyroEXT(PlayerIndex.One, out gyro); GamePad.GetAccelerometerEXT(PlayerIndex.One, out accel); // Have fun! } Button Extensions A number of bitflags have been added to the Buttons enum - they are as follows: Misc1EXT = 0x00000400, Paddle1EXT = 0x00010000, Paddle2EXT = 0x00020000, Paddle3EXT = 0x00040000, Paddle4EXT = 0x00080000, TouchPadEXT = 0x00100000 Polling these works the same way as the other buttons, call GamePadState.IsButtonDown/IsButtonUp to check for them. Note that we did NOT add properties to the GamePadButtons struct, nor did we add a new GamePadState struct, but we did add matching properties to GamePadCapabilities . Content Extensions Unlike XNA, Content.Load<> can also import raw (non-XNB) assets in various file formats. The list of supported formats for each content type is as follows: Effect: FXB Song: OGG/OGA, QOA SoundEffect: WAV Texture2D: BMP, GIF, JPEG, PNG, TGA, TIFF, DDS, QOI TextureCube: DDS Video: OGG/OGV SurfaceFormat Extensions A handful of texture formats have been added for various reasons - they are listed below: ColorBgraEXT allows the use of BGRA8 texture data, rather than SurfaceFormat.Color's RGBA8 format. This is likely only useful if you are preserving data packed by the XNA 3.1 content pipeline. ColorSrgbEXT and Dxt5SrgbEXT expose sRGB colorspaces to Textures and RenderTargets, where supported. Bc7EXT and Bc7SrgbEXT expose BC7 compression support, where supported. FNALoggerEXT public static class Microsoft.Xna.Framework.FNALoggerEXT is a new class that exposes FNA's internal logging system. Simply assign the Log functions inside to use your own logging system, if desired. To use the FNALoggerEXT extension: static void Main(string[] args) { /* We recommend setting this before touching anything XNA-related! */ FNALoggerEXT.LogInfo = (msg) => MyLogger.Log(\"FNA\", \"INFORMATION\", msg); FNALoggerEXT.LogWarn = (msg) => MyLogger.Log(\"FNA\", \"WARNING\", msg); FNALoggerEXT.LogError = (msg) => MyLogger.Log(\"FNA\", \"ERROR\", msg); } IsBorderlessEXT public bool IsBorderlessEXT { get; set; } is a new property for GameWindow that gives you the ability to show/hide the window border without having to perform direct interop on the Handle pointer. To use the IsBorderlessEXT extension: public void ApplyVideoSettings() { graphicsDeviceManager.ApplyChanges(); /* We recommend setting this after calling ApplyChanges! */ game.Window.IsBorderlessEXT = wantsBorderless; } SetStringMarkerEXT public void SetStringMarker(string text) is a new method for GraphicsDevice that abstracts access to functions like glStringMarkerGREMEDY and D3DPERF_SetMarker . It should only be accessed in a debug context! To use the SetStringMarkerEXT extension: [Conditional(\"DEBUG\")] public void GraphicsDebugString(string text) { graphicsDevice.SetStringMarkerEXT(text); } public void DrawStuff() { GraphicsDebugString(\"First set of polygons\"); graphicsDevice.DrawIndexedPrimitives(...); GraphicsDebugString(\"Second set of polygons\"); graphicsDevice.DrawIndexedPrimitives(...); } GetKeyFromScancodeEXT public static Keys GetKeyFromScancodeEXT(Keys scancode) is a new method for Keyboard that translates a Keys value, interpreted as a scancode, into the actual Keys value based on the current keyboard layout. For example, on an AZERTY keyboard, GetKeyFromScancode(Keys.Q) will return Keys.A. If FNA_KEYBOARD_USE_SCANCODES is enabled, the return value will always be the same as the input value. To use the GetKeyFromScancodeEXT extension: private Keys PlayerForward; private Keys PlayerBackward; private Keys PlayerStrafeLeft; private Keys PlayerStrafeRight; private Keys PlayerUse; public void AssignDefaultKeys() { // Typically you might just assign a Keys value directly. Not here! PlayerForward = Keyboard.GetKeyFromScancodeEXT(Keys.W); PlayerBackward = Keyboard.GetKeyFromScancodeEXT(Keys.S); PlayerStrafeLeft = Keyboard.GetKeyFromScancodeEXT(Keys.A); PlayerStrafeRight = Keyboard.GetKeyFromScancodeEXT(Keys.D); PlayerUse = Keyboard.GetKeyFromScancodeEXT(Keys.E); } TextInputEXT public static class Microsoft.Xna.Framework.TextInputEXT is a new class that partially abstracts text input event handling. To use the TextInputEXT extension: using Microsoft.Xna.Framework.Input; private void OnTextInput(char c) { if (c == (char) 22) { System.Console.WriteLine(\"PASTED: \" + SDL3.SDL.SDL_GetClipboardText()); } System.Console.WriteLine(\"TEXT ENTERED: \" + c.ToString()); } public void StartTextInput() { TextInputEXT.TextInput += OnTextInput; TextInputEXT.StartTextInput(); } public void StopTextInput() { TextInputEXT.StopTextInput(); TextInputEXT.TextInput -= OnTextInput; } In addition to standard text input, the TextInput event can push one of a series of symbols to represent various text input actions: (char) 2 - Home (char) 3 - End (char) 8 - Backspace (char) 9 - Tab (char) 13 - Enter (char) 127 - Delete (char) 22 - Control+V (Paste operator) ClickedEXT public static Action<int> ClickedEXT is a new event for Mouse that allows you to receive notifications when a mouse button is clicked. One of the main flaws of the XNA Mouse API is that you are only able to get the \"current\" state of the mouse buttons, but mouse button input is unique due to the various ways input events can be sent. Consider the following code: // Accessible by the rest of the engine public bool ButtonDown { get; private set; } // Somewhere in the event loop... if (evt.type == MOUSEBUTTONDOWN) { ButtonDown = true; } else if (evt.type == MOUSEBUTTONUP) { ButtonDown = false; } // Somewhere in the game... if (Input.ButtonDown) { // Stuff! } For mouse input in particular it is surprisingly common for both a button down and a button up event to show up in a single frame, so when you poll for the \"current\" state, you miss out on at least one input change, leading to dropped input. This is far more noticeable when using a mouse that uses tap/touch events to send mouse buttons, rather than a physical button (for example, laptop trackpads). ClickedEXT will send a button index each time a mouse button is clicked: // Reset this array at the end of each frame! private ButtonState[] mouseClicks = new ButtonState[5]; private void OnClicked(int button) { mouseClicks[button] = ButtonState.Pressed; } This should be combined with the standard XNA Mouse API to get a fully accurate mouse button state: ClickedEXT GetState Final State \u2714\ufe0f \u2714\ufe0f Clicked, Pressing \u274c \u274c Released \u2714\ufe0f \u274c Clicked, Released \u274c \u2714\ufe0f Pressing The following is a basic example of ClickedEXT combined with GetState: // Using the code above... // ButtonState doesn't tell us enough, let's make our own! public enum InputState { Released, Pressing, Clicked } public InputState LeftMouseButton { get; private set; } // GetState storage MouseState mPrevState, mState = new MouseState(); public void UpdateInput() { mPrevState = mState; mState = Mouse.GetState(); // Easiest route is to 'or' the click with the current state ButtonState leftButton = mState.LeftButton | mouseClicks[0]; if (leftButton == ButtonState.Released) { LeftMouseButton = InputState.Released; } else if (mPrevState.LeftButton == ButtonState.Released) { LeftMouseButton = InputState.Clicked; } else { LeftMouseButton = InputState.Pressing; } // Remember to clear your click storage each frame! mouseClicks[0] = ButtonState.Released; } Note that ClickedEXT can send multiple clicks for a single button if it is in fact clicked multiple times (for example, if the game hitches briefly and gives the user time to click repeatedly in one frame). IsRelativeMouseModeEXT public static bool IsRelativeMouseModeEXT is a new property for Mouse that allows you to change the behavior of Mouse.GetState() to get relative (rather than absolute) X/Y coordinates. As part of this, it also automatically locks the mouse to the window. This is particularly helpful for first-person games, where you would otherwise have to constantly call Mouse.SetPosition() to keep the mouse in place. To use the IsRelativeMouseModeEXT extension: public static bool EnableMouseCapture() { /* PSA: Please make mouse capture an option * in your settings menu if it's not required! * Also, maybe disable this when !IsActive. */ Mouse.IsRelativeMouseModeEXT = true; } public static void UpdateMouseInput() { Vector2 cursorChange; CurrentMouseState = Mouse.GetState(); #if FNA // Yup, that's it! cursorChange = new Vector2(CurrentMouseState.X, CurrentMouseState.Y); #else // I don't feel so good... cursorChange = new Vector2( CurrentMouseState.X - screenCenter.X, CurrentMouseState.Y - screenCenter.Y ); Mouse.SetPosition(screenCenter.X, screenCenter.Y); // BARF #endif } SubmitFloatBufferEXT public void SubmitFloatBufferEXT(float[] buffer) is a new method for DynamicSoundEffectInstance that allows you to directly submit float samples to the source, without having to convert to signed 16-bit PCM data. Typically this is used to directly stream float samples that are often provided by default in audio decoders. This function is used exactly as the official SubmitBuffer method is used in XNA. TextureDataFromStreamEXT public static void TextureDataFromStreamEXT(Stream stream, out int width, out int height, out byte[] pixels) is a new method for Texture2D that functions similarly to Texture2D.FromStream() , except that it does not generate a Texture2D instance. This is a convenience function that will only decode the image data for you. DDSFromStreamEXT public static Texture DDSFromStreamEXT(GraphicsDevice graphicsDevice, Stream stream) is a new method for Texture2D/TextureCube that functions similarly to Texture2D.FromStream() , but is specialized for loading DDS texture files. Currently this extension supports the Dxt1, Dxt3, Dxt5, ColorBgraEXT, and Dxt5SrgbEXT formats. This extension also allows loading DDS image files via the Content.Load<Texture2D/TextureCube>() methods. GetFormatSizeEXT, GetBlockSizeSquaredEXT Two new methods for Texture are exposed to help with allocating texture staging memory. The Texture.GetBlockSizeSquaredEXT method allows querying the number of pixels in a block for compressed textures. You can use this in order to round sizes up/down to the nearest block, or to calculate how large a buffer needs to be for a compressed texture of a given size. Most compressed texture formats have a block size of 4 (and thus a BlockSizeSquared of 16 ), but not all do. For formats that are not compressed, this method returns 1 . The Texture.GetFormatSizeEXT method allows querying the number of bytes in a single block (or texel, for formats where the block size is 1 ). For the Color format, for example, this is 4 . By combining these two methods you can calculate the appropriate buffer size for any arbitrary GetData call, like so: var elementSize = Texture.GetFormatSizeEXT(texture.Format); var blockSizeSquared = Texture.GetBlockSizeSquaredEXT(texture.Format); var buffer = new byte[texture.Width * texture.Height * elementSize / blockSizeSquared]; texture.GetData(buffer); SetDataPointerEXT public void SetDataPointerEXT is a new method for Buffer and Texture objects that lets you send data directly via IntPtrs rather than arrays. This is ideal for scenarios where you know your input data is valid and want to skip all the managed validation/marshaling that happens with the normal SetData functions. Be warned: When I say this skips all the validation, I mean it! This will crash if you don't know what you're doing! PointListEXT PointListEXT is an additional enum value for PrimitiveType that allows for point rendering. While FNA supports rendering point vertex data, note that the feature is very strict - we do not expose any other aspect of point rendering that existed in XNA3 and older graphics APIs. Point sprites are always enabled, and you are expected to specify point size and manage min/max sizes either in your vertex data or vertex shader, whichever is more appropriate for your application. GetRenderTargetsNoAllocEXT public int GetRenderTargetsNoAllocEXT(RenderTargetBinding[] output) is a new method that acts similarly to GetRenderTargets, but allows for avoiding allocating a new array for each call: RenderTargetBinding[] oldTargets = new RenderTargetBinding[0]; // Declared somewhere else, I hope... int oldTargetCount = currentDevice.GetRenderTargetsNoAllocEXT(null); Array.Resize(ref oldTargets, oldTargetCount); currentDevice.GetRenderTargetsNoAllocEXT(oldTargets); SetAudioTrackEXT, SetVideoTrackEXT public void SetAudioTrackEXT(int track) and public void SetVideoTrackEXT(int track) are new methods for Video that enable support for multiple tracks in a single video file. This is useful for supporting multiple languages without having to duplicate video data. Note that this function may have some delay when set mid-stream, as the decoder may need to complete its current audio packet before moving to the new track. To ensure a 100% clean track, call this before calling VideoPlayer.Play() ! Currently, you are only allowed to change audio tracks mid-stream when the channel count and sample rate match the previous track. Changing to a track with a different wave format is unsupported unless done before playback begins. Video tracks must match in width, height, and YUV format. Mixing image formats in a single file is unsupported. FromUriEXT This is a new method for Video that works exactly as Song does - see the Song API for details! FingerIdEXT public int GestureSample.FingerIdEXT and public int GestureSample.FingerId2EXT are new properties for GestureSample that allow you to determine exactly which touch finger(s) were involved in the gesture. Note that FingerId2EXT is only used for Pinch and PinchComplete gestures, and it will have a value of -1 for any other gesture type. The following is a basic example of using these properties: // Keep track of which fingers were used for these gestures private int DragFinger = -1; private int PinchFinger1 = -1; private int PinchFinger2 = -1; // Somewhere later... while (TouchPanel.IsGestureAvailable) { GestureSample gesture = TouchPanel.ReadGesture(); if (gesture.GestureType == GestureType.Drag) { DragFinger = gesture.FingerIdEXT; } else if (gesture.GestureType == GestureType.Pinch) { PinchFinger1 = gesture.FingerIdEXT; PinchFinger2 = gesture.FingerId2EXT; } }","title":"5: FNA Extensions"},{"location":"5%3A-FNA-Extensions/#5-fna-extensions","text":"FNA, in rare cases, will provide extensions to the XNA 4.0 Refresh specification in order to simplify often-unportable tasks, provide feature parity with other projects such as the MonoGame project, and so on.","title":"5: FNA Extensions"},{"location":"5%3A-FNA-Extensions/#gamepad-extensions","text":"The GamePad extensions are unique in that there are a lot of them (our policy is generally to not extend the spec unless it's a life-or-death situation) and that they are pretty much universally recommended to use, unlike the other extensions which generally exist for very specific use cases. FNA currently has the following extensions for controller support:","title":"GamePad Extensions"},{"location":"5%3A-FNA-Extensions/#getguidext","text":"public static string GetGUIDEXT(PlayerIndex playerIndex) is a new method for GamePad that allows you to get the hardware GUID for a given controller. Since GUIDs are organized differently depending on the OS, we have abstracted the GUID string into a shortened, unified format that is consistent across operating systems. To use the GetGUIDEXT extension: public MyControllerType GetControllerType(PlayerIndex index) { /* Try to only do this once on initialization! It's slow! */ string guid = GamePad.GetGUIDEXT(index); if (guid.Equals(\"4c05c405\") || guid.Equals(\"4c05cc09\")) { return MyControllerType.PS4; } if (guid.Equals(\"4c05e60c\")) { return MyControllerType.PS5; } if (guid.Equals(\"7e050920\") || guid.Equals(\"7e053003\")) { return MyControllerType.Nintendo; } return MyControllerType.Xbox; }","title":"GetGUIDEXT"},{"location":"5%3A-FNA-Extensions/#setlightbarext","text":"public static void SetLightBarEXT(PlayerIndex playerIndex, Color color) is a new method for GamePad that allows you to set the color of the light bar on the DualShock 4 and DualSense controllers. There is a matching bool HasLightBarEXT property in GamePadCapabilities . To use the SetLightBarEXT extension: public void UpdateLightBar() { if (playerIsDead) { GamePad.SetLightBarEXT(index, Color.Red); } else { GamePad.SetLightBarEXT(index, Color.Green); } }","title":"SetLightBarEXT"},{"location":"5%3A-FNA-Extensions/#settriggervibrationext","text":"public static bool SetTriggerVibrationEXT is a new method for GamePad that allows setting the speed of motors specifically found in the triggers - this is found in the Xbox One controller, for example. There is a matching bool HasTriggerVibrationMotorsEXT property in GamePadCapabilities . The function is used in exactly the same way as SetVibration , so wherever you have a SetVibration in your game you will probably want a SetTriggerVibrationEXT call as well, should you choose to support trigger-specific haptics.","title":"SetTriggerVibrationEXT"},{"location":"5%3A-FNA-Extensions/#getgyroextgetaccelerometerext","text":"public static bool GetGyroEXT/GetAccelerometerEXT are new methods for GamePad that poll the state of a gyro in a controller, should they exist (the PS4 and Switch controllers have them, for example). There are matching bool HasGyroEXT/HasAccelerometerEXT properties in GamePadCapabilities . To use the extensions: public static void DoMotionControls() { Vector3 gyro, accel; GamePad.GetGyroEXT(PlayerIndex.One, out gyro); GamePad.GetAccelerometerEXT(PlayerIndex.One, out accel); // Have fun! }","title":"GetGyroEXT/GetAccelerometerEXT"},{"location":"5%3A-FNA-Extensions/#button-extensions","text":"A number of bitflags have been added to the Buttons enum - they are as follows: Misc1EXT = 0x00000400, Paddle1EXT = 0x00010000, Paddle2EXT = 0x00020000, Paddle3EXT = 0x00040000, Paddle4EXT = 0x00080000, TouchPadEXT = 0x00100000 Polling these works the same way as the other buttons, call GamePadState.IsButtonDown/IsButtonUp to check for them. Note that we did NOT add properties to the GamePadButtons struct, nor did we add a new GamePadState struct, but we did add matching properties to GamePadCapabilities .","title":"Button Extensions"},{"location":"5%3A-FNA-Extensions/#content-extensions","text":"Unlike XNA, Content.Load<> can also import raw (non-XNB) assets in various file formats. The list of supported formats for each content type is as follows: Effect: FXB Song: OGG/OGA, QOA SoundEffect: WAV Texture2D: BMP, GIF, JPEG, PNG, TGA, TIFF, DDS, QOI TextureCube: DDS Video: OGG/OGV","title":"Content Extensions"},{"location":"5%3A-FNA-Extensions/#surfaceformat-extensions","text":"A handful of texture formats have been added for various reasons - they are listed below: ColorBgraEXT allows the use of BGRA8 texture data, rather than SurfaceFormat.Color's RGBA8 format. This is likely only useful if you are preserving data packed by the XNA 3.1 content pipeline. ColorSrgbEXT and Dxt5SrgbEXT expose sRGB colorspaces to Textures and RenderTargets, where supported. Bc7EXT and Bc7SrgbEXT expose BC7 compression support, where supported.","title":"SurfaceFormat Extensions"},{"location":"5%3A-FNA-Extensions/#fnaloggerext","text":"public static class Microsoft.Xna.Framework.FNALoggerEXT is a new class that exposes FNA's internal logging system. Simply assign the Log functions inside to use your own logging system, if desired. To use the FNALoggerEXT extension: static void Main(string[] args) { /* We recommend setting this before touching anything XNA-related! */ FNALoggerEXT.LogInfo = (msg) => MyLogger.Log(\"FNA\", \"INFORMATION\", msg); FNALoggerEXT.LogWarn = (msg) => MyLogger.Log(\"FNA\", \"WARNING\", msg); FNALoggerEXT.LogError = (msg) => MyLogger.Log(\"FNA\", \"ERROR\", msg); }","title":"FNALoggerEXT"},{"location":"5%3A-FNA-Extensions/#isborderlessext","text":"public bool IsBorderlessEXT { get; set; } is a new property for GameWindow that gives you the ability to show/hide the window border without having to perform direct interop on the Handle pointer. To use the IsBorderlessEXT extension: public void ApplyVideoSettings() { graphicsDeviceManager.ApplyChanges(); /* We recommend setting this after calling ApplyChanges! */ game.Window.IsBorderlessEXT = wantsBorderless; }","title":"IsBorderlessEXT"},{"location":"5%3A-FNA-Extensions/#setstringmarkerext","text":"public void SetStringMarker(string text) is a new method for GraphicsDevice that abstracts access to functions like glStringMarkerGREMEDY and D3DPERF_SetMarker . It should only be accessed in a debug context! To use the SetStringMarkerEXT extension: [Conditional(\"DEBUG\")] public void GraphicsDebugString(string text) { graphicsDevice.SetStringMarkerEXT(text); } public void DrawStuff() { GraphicsDebugString(\"First set of polygons\"); graphicsDevice.DrawIndexedPrimitives(...); GraphicsDebugString(\"Second set of polygons\"); graphicsDevice.DrawIndexedPrimitives(...); }","title":"SetStringMarkerEXT"},{"location":"5%3A-FNA-Extensions/#getkeyfromscancodeext","text":"public static Keys GetKeyFromScancodeEXT(Keys scancode) is a new method for Keyboard that translates a Keys value, interpreted as a scancode, into the actual Keys value based on the current keyboard layout. For example, on an AZERTY keyboard, GetKeyFromScancode(Keys.Q) will return Keys.A. If FNA_KEYBOARD_USE_SCANCODES is enabled, the return value will always be the same as the input value. To use the GetKeyFromScancodeEXT extension: private Keys PlayerForward; private Keys PlayerBackward; private Keys PlayerStrafeLeft; private Keys PlayerStrafeRight; private Keys PlayerUse; public void AssignDefaultKeys() { // Typically you might just assign a Keys value directly. Not here! PlayerForward = Keyboard.GetKeyFromScancodeEXT(Keys.W); PlayerBackward = Keyboard.GetKeyFromScancodeEXT(Keys.S); PlayerStrafeLeft = Keyboard.GetKeyFromScancodeEXT(Keys.A); PlayerStrafeRight = Keyboard.GetKeyFromScancodeEXT(Keys.D); PlayerUse = Keyboard.GetKeyFromScancodeEXT(Keys.E); }","title":"GetKeyFromScancodeEXT"},{"location":"5%3A-FNA-Extensions/#textinputext","text":"public static class Microsoft.Xna.Framework.TextInputEXT is a new class that partially abstracts text input event handling. To use the TextInputEXT extension: using Microsoft.Xna.Framework.Input; private void OnTextInput(char c) { if (c == (char) 22) { System.Console.WriteLine(\"PASTED: \" + SDL3.SDL.SDL_GetClipboardText()); } System.Console.WriteLine(\"TEXT ENTERED: \" + c.ToString()); } public void StartTextInput() { TextInputEXT.TextInput += OnTextInput; TextInputEXT.StartTextInput(); } public void StopTextInput() { TextInputEXT.StopTextInput(); TextInputEXT.TextInput -= OnTextInput; } In addition to standard text input, the TextInput event can push one of a series of symbols to represent various text input actions: (char) 2 - Home (char) 3 - End (char) 8 - Backspace (char) 9 - Tab (char) 13 - Enter (char) 127 - Delete (char) 22 - Control+V (Paste operator)","title":"TextInputEXT"},{"location":"5%3A-FNA-Extensions/#clickedext","text":"public static Action<int> ClickedEXT is a new event for Mouse that allows you to receive notifications when a mouse button is clicked. One of the main flaws of the XNA Mouse API is that you are only able to get the \"current\" state of the mouse buttons, but mouse button input is unique due to the various ways input events can be sent. Consider the following code: // Accessible by the rest of the engine public bool ButtonDown { get; private set; } // Somewhere in the event loop... if (evt.type == MOUSEBUTTONDOWN) { ButtonDown = true; } else if (evt.type == MOUSEBUTTONUP) { ButtonDown = false; } // Somewhere in the game... if (Input.ButtonDown) { // Stuff! } For mouse input in particular it is surprisingly common for both a button down and a button up event to show up in a single frame, so when you poll for the \"current\" state, you miss out on at least one input change, leading to dropped input. This is far more noticeable when using a mouse that uses tap/touch events to send mouse buttons, rather than a physical button (for example, laptop trackpads). ClickedEXT will send a button index each time a mouse button is clicked: // Reset this array at the end of each frame! private ButtonState[] mouseClicks = new ButtonState[5]; private void OnClicked(int button) { mouseClicks[button] = ButtonState.Pressed; } This should be combined with the standard XNA Mouse API to get a fully accurate mouse button state: ClickedEXT GetState Final State \u2714\ufe0f \u2714\ufe0f Clicked, Pressing \u274c \u274c Released \u2714\ufe0f \u274c Clicked, Released \u274c \u2714\ufe0f Pressing The following is a basic example of ClickedEXT combined with GetState: // Using the code above... // ButtonState doesn't tell us enough, let's make our own! public enum InputState { Released, Pressing, Clicked } public InputState LeftMouseButton { get; private set; } // GetState storage MouseState mPrevState, mState = new MouseState(); public void UpdateInput() { mPrevState = mState; mState = Mouse.GetState(); // Easiest route is to 'or' the click with the current state ButtonState leftButton = mState.LeftButton | mouseClicks[0]; if (leftButton == ButtonState.Released) { LeftMouseButton = InputState.Released; } else if (mPrevState.LeftButton == ButtonState.Released) { LeftMouseButton = InputState.Clicked; } else { LeftMouseButton = InputState.Pressing; } // Remember to clear your click storage each frame! mouseClicks[0] = ButtonState.Released; } Note that ClickedEXT can send multiple clicks for a single button if it is in fact clicked multiple times (for example, if the game hitches briefly and gives the user time to click repeatedly in one frame).","title":"ClickedEXT"},{"location":"5%3A-FNA-Extensions/#isrelativemousemodeext","text":"public static bool IsRelativeMouseModeEXT is a new property for Mouse that allows you to change the behavior of Mouse.GetState() to get relative (rather than absolute) X/Y coordinates. As part of this, it also automatically locks the mouse to the window. This is particularly helpful for first-person games, where you would otherwise have to constantly call Mouse.SetPosition() to keep the mouse in place. To use the IsRelativeMouseModeEXT extension: public static bool EnableMouseCapture() { /* PSA: Please make mouse capture an option * in your settings menu if it's not required! * Also, maybe disable this when !IsActive. */ Mouse.IsRelativeMouseModeEXT = true; } public static void UpdateMouseInput() { Vector2 cursorChange; CurrentMouseState = Mouse.GetState(); #if FNA // Yup, that's it! cursorChange = new Vector2(CurrentMouseState.X, CurrentMouseState.Y); #else // I don't feel so good... cursorChange = new Vector2( CurrentMouseState.X - screenCenter.X, CurrentMouseState.Y - screenCenter.Y ); Mouse.SetPosition(screenCenter.X, screenCenter.Y); // BARF #endif }","title":"IsRelativeMouseModeEXT"},{"location":"5%3A-FNA-Extensions/#submitfloatbufferext","text":"public void SubmitFloatBufferEXT(float[] buffer) is a new method for DynamicSoundEffectInstance that allows you to directly submit float samples to the source, without having to convert to signed 16-bit PCM data. Typically this is used to directly stream float samples that are often provided by default in audio decoders. This function is used exactly as the official SubmitBuffer method is used in XNA.","title":"SubmitFloatBufferEXT"},{"location":"5%3A-FNA-Extensions/#texturedatafromstreamext","text":"public static void TextureDataFromStreamEXT(Stream stream, out int width, out int height, out byte[] pixels) is a new method for Texture2D that functions similarly to Texture2D.FromStream() , except that it does not generate a Texture2D instance. This is a convenience function that will only decode the image data for you.","title":"TextureDataFromStreamEXT"},{"location":"5%3A-FNA-Extensions/#ddsfromstreamext","text":"public static Texture DDSFromStreamEXT(GraphicsDevice graphicsDevice, Stream stream) is a new method for Texture2D/TextureCube that functions similarly to Texture2D.FromStream() , but is specialized for loading DDS texture files. Currently this extension supports the Dxt1, Dxt3, Dxt5, ColorBgraEXT, and Dxt5SrgbEXT formats. This extension also allows loading DDS image files via the Content.Load<Texture2D/TextureCube>() methods.","title":"DDSFromStreamEXT"},{"location":"5%3A-FNA-Extensions/#getformatsizeext-getblocksizesquaredext","text":"Two new methods for Texture are exposed to help with allocating texture staging memory. The Texture.GetBlockSizeSquaredEXT method allows querying the number of pixels in a block for compressed textures. You can use this in order to round sizes up/down to the nearest block, or to calculate how large a buffer needs to be for a compressed texture of a given size. Most compressed texture formats have a block size of 4 (and thus a BlockSizeSquared of 16 ), but not all do. For formats that are not compressed, this method returns 1 . The Texture.GetFormatSizeEXT method allows querying the number of bytes in a single block (or texel, for formats where the block size is 1 ). For the Color format, for example, this is 4 . By combining these two methods you can calculate the appropriate buffer size for any arbitrary GetData call, like so: var elementSize = Texture.GetFormatSizeEXT(texture.Format); var blockSizeSquared = Texture.GetBlockSizeSquaredEXT(texture.Format); var buffer = new byte[texture.Width * texture.Height * elementSize / blockSizeSquared]; texture.GetData(buffer);","title":"GetFormatSizeEXT, GetBlockSizeSquaredEXT"},{"location":"5%3A-FNA-Extensions/#setdatapointerext","text":"public void SetDataPointerEXT is a new method for Buffer and Texture objects that lets you send data directly via IntPtrs rather than arrays. This is ideal for scenarios where you know your input data is valid and want to skip all the managed validation/marshaling that happens with the normal SetData functions. Be warned: When I say this skips all the validation, I mean it! This will crash if you don't know what you're doing!","title":"SetDataPointerEXT"},{"location":"5%3A-FNA-Extensions/#pointlistext","text":"PointListEXT is an additional enum value for PrimitiveType that allows for point rendering. While FNA supports rendering point vertex data, note that the feature is very strict - we do not expose any other aspect of point rendering that existed in XNA3 and older graphics APIs. Point sprites are always enabled, and you are expected to specify point size and manage min/max sizes either in your vertex data or vertex shader, whichever is more appropriate for your application.","title":"PointListEXT"},{"location":"5%3A-FNA-Extensions/#getrendertargetsnoallocext","text":"public int GetRenderTargetsNoAllocEXT(RenderTargetBinding[] output) is a new method that acts similarly to GetRenderTargets, but allows for avoiding allocating a new array for each call: RenderTargetBinding[] oldTargets = new RenderTargetBinding[0]; // Declared somewhere else, I hope... int oldTargetCount = currentDevice.GetRenderTargetsNoAllocEXT(null); Array.Resize(ref oldTargets, oldTargetCount); currentDevice.GetRenderTargetsNoAllocEXT(oldTargets);","title":"GetRenderTargetsNoAllocEXT"},{"location":"5%3A-FNA-Extensions/#setaudiotrackext-setvideotrackext","text":"public void SetAudioTrackEXT(int track) and public void SetVideoTrackEXT(int track) are new methods for Video that enable support for multiple tracks in a single video file. This is useful for supporting multiple languages without having to duplicate video data. Note that this function may have some delay when set mid-stream, as the decoder may need to complete its current audio packet before moving to the new track. To ensure a 100% clean track, call this before calling VideoPlayer.Play() ! Currently, you are only allowed to change audio tracks mid-stream when the channel count and sample rate match the previous track. Changing to a track with a different wave format is unsupported unless done before playback begins. Video tracks must match in width, height, and YUV format. Mixing image formats in a single file is unsupported.","title":"SetAudioTrackEXT, SetVideoTrackEXT"},{"location":"5%3A-FNA-Extensions/#fromuriext","text":"This is a new method for Video that works exactly as Song does - see the Song API for details!","title":"FromUriEXT"},{"location":"5%3A-FNA-Extensions/#fingeridext","text":"public int GestureSample.FingerIdEXT and public int GestureSample.FingerId2EXT are new properties for GestureSample that allow you to determine exactly which touch finger(s) were involved in the gesture. Note that FingerId2EXT is only used for Pinch and PinchComplete gestures, and it will have a value of -1 for any other gesture type. The following is a basic example of using these properties: // Keep track of which fingers were used for these gestures private int DragFinger = -1; private int PinchFinger1 = -1; private int PinchFinger2 = -1; // Somewhere later... while (TouchPanel.IsGestureAvailable) { GestureSample gesture = TouchPanel.ReadGesture(); if (gesture.GestureType == GestureType.Drag) { DragFinger = gesture.FingerIdEXT; } else if (gesture.GestureType == GestureType.Pinch) { PinchFinger1 = gesture.FingerIdEXT; PinchFinger2 = gesture.FingerId2EXT; } }","title":"FingerIdEXT"},{"location":"6%3A-FNA-Build-Options/","text":"6: FNA Build Options FNA's implementation of certain features may be configurable at build time - that is, parts of the implementation may be temporarily modified to allow for easier debugging. To enable these options, create a file next to your .sln file called FNA.Settings.props , which will look something like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <PropertyGroup> <DefineConstants>VERBOSE_PIPELINECACHE;$(DefineConstants)</DefineConstants> </PropertyGroup> </Project> You can also use this file to sneak in other bits and pieces, such as adding SDL2_image to the build (as an aside, be sure to update FNA.dll.config with dllmaps if you actually do this): <?xml version=\"1.0\" encoding=\"utf-8\"?> <Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <ItemGroup> <Compile Include=\"lib\\SDL2-CS\\src\\SDL2_image.cs\" /> </ItemGroup> </Project> The supported build options are listed below! VERBOSE_PIPELINECACHE CASE_SENSITIVITY_HACK VERBOSE_PIPELINECACHE Affected file: src/Graphics/PipelineCache.cs If you want to debug the PipelineCache to make sure it's interpreting your Effects' render state changes properly, you can enable this and get a bunch of messages logged to FNALoggerEXT. CASE_SENSITIVITY_HACK Affected file: src/TitleContainer.cs On Linux, the file system is case sensitive. This means that unless you really focused on it, there's a good chance that your filenames are not actually accurate! The result: File/DirectoryNotFound. This is a quick alternative to MONO_IOMAP=all, but the point is that you should NOT depend on either of these two things. PLEASE fix your paths!","title":"6: FNA Build Options"},{"location":"6%3A-FNA-Build-Options/#6-fna-build-options","text":"FNA's implementation of certain features may be configurable at build time - that is, parts of the implementation may be temporarily modified to allow for easier debugging. To enable these options, create a file next to your .sln file called FNA.Settings.props , which will look something like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <PropertyGroup> <DefineConstants>VERBOSE_PIPELINECACHE;$(DefineConstants)</DefineConstants> </PropertyGroup> </Project> You can also use this file to sneak in other bits and pieces, such as adding SDL2_image to the build (as an aside, be sure to update FNA.dll.config with dllmaps if you actually do this): <?xml version=\"1.0\" encoding=\"utf-8\"?> <Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <ItemGroup> <Compile Include=\"lib\\SDL2-CS\\src\\SDL2_image.cs\" /> </ItemGroup> </Project> The supported build options are listed below! VERBOSE_PIPELINECACHE CASE_SENSITIVITY_HACK","title":"6: FNA Build Options"},{"location":"6%3A-FNA-Build-Options/#verbose_pipelinecache","text":"Affected file: src/Graphics/PipelineCache.cs If you want to debug the PipelineCache to make sure it's interpreting your Effects' render state changes properly, you can enable this and get a bunch of messages logged to FNALoggerEXT.","title":"VERBOSE_PIPELINECACHE"},{"location":"6%3A-FNA-Build-Options/#case_sensitivity_hack","text":"Affected file: src/TitleContainer.cs On Linux, the file system is case sensitive. This means that unless you really focused on it, there's a good chance that your filenames are not actually accurate! The result: File/DirectoryNotFound. This is a quick alternative to MONO_IOMAP=all, but the point is that you should NOT depend on either of these two things. PLEASE fix your paths!","title":"CASE_SENSITIVITY_HACK"},{"location":"7%3A-FNA-Environment-Variables/","text":"7: FNA Environment Variables FNA will check for certain environment variables to perform certain tasks in a non-default manner. For the most part these are meant to be used by both developers and customers, but there are also cases where we use environment variables as a means of working around a specific problem without requiring a build-time option/configuration. NOTE: .NET Core intentionally broke native library compatibility with System.Environment.SetEnvironmentVariable , so for any FNA3D environment variables, we recommend using SDL_SetHint instead, even though this will have to be updated when SDL3 is released. The documentation below uses this function, if you need an example. (You are of course welcome to continue using .NET Framework and Mono instead, which does not have this issue.) FNA: FNA_GRAPHICS_ENABLE_HIGHDPI FNA_GRAPHICS_JPEG_SAVE_QUALITY FNA_KEYBOARD_USE_SCANCODES FNA_GAMEPAD_NUM_GAMEPADS FNA_SDL_FORCE_BASE_PATH FNA3D: FNA3D_FORCE_DRIVER FNA3D_ENABLE_HDR_COLORSPACE FNA3D_ENABLE_LATESWAPTEAR FNA3D_MOJOSHADER_PROFILE FNA3D_BACKBUFFER_SCALE_NEAREST FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT FNA3D_OPENGL_FORCE_ES3 FNA3D_OPENGL_FORCE_CORE_PROFILE FNA3D_OPENGL_FORCE_COMPATIBILITY_PROFILE FNA_GRAPHICS_ENABLE_HIGHDPI While many modern displays are capable of much higher DPIs (such as \"Retina\" displays on macOS and iOS), XNA does not have any mechanism for supporting high-DPI rendering. Enabling this feature is as simple as setting this before creating your Game: Environment.SetEnvironmentVariable(\"FNA_GRAPHICS_ENABLE_HIGHDPI\", \"1\"); After calling your Game constructor, you can then check to see if high-DPI creation was successful: Settings.HighDPI = Environment.GetEnvironmentVariable(\"FNA_GRAPHICS_ENABLE_HIGHDPI\") == \"1\"; While it is possible for us to create windows with high-DPI drawing space, we cannot guarantee that it will be available at all times. Worse, we can only acquire this feature on startup, so toggling high-DPI mode will require restarting your game. When this is enabled, the drawable size will take priority over the window size. So, when running at 1920x1080 in windowed mode, the drawable size will be 1920x1080, but the window size will be 960x540. This allows users to set the game resolution to the maximum resolution allowed by the OS while having the appropriate window size. In fullscreen mode we will continue to run at the desktop resolution with a faux-backbuffer for non-native resolutions, but in high-DPI mode the native resolution will now be the actual native resolution rather than the simulated resolution. As always, be sure that your RenderTargets and Viewports match the backbuffer size and NOT the window size! Lastly, when packaging for macOS, be sure this is in your app bundle's Info.plist: <key>NSHighResolutionCapable</key> <string>True</string> This variable is accessible to users by passing /enablehighdpi:1 as a launch option. FNA_GRAPHICS_JPEG_SAVE_QUALITY For some reason they didn't expose a quality parameter to SaveAsJpeg, so we added one ourselves! This variable is checked each time you call the function, so feel free to customize this based on the context for each time you save an image. The value is expected to be between 1 and 100. FNA_KEYBOARD_USE_SCANCODES XNA keys are based on keycodes, rather than scancodes. With SDL, for example, you can actually pick between SDL_Keycode and SDL_Scancode, but scancodes will not be accurate to XNA4. The benefit is that scancodes will ignore \"foreign\" keyboard layouts, making default keyboard layouts work out of the box everywhere (unless the actual symbol for the keys matters in your game). While FNA provides the GetKeyFromScancodeEXT extension and developers are encouraged to use it, this is not a required function and users may benefit from this environment variable in the event that layouts are not checked in-game. In either case, TextInputEXT will still read the actual chars correctly, so you can (mostly) have your cake and eat it too if you don't care about your bindings menu not making a lot of sense on foreign layouts. To use scancodes instead of keycodes, set this variable to \"1\" before starting the game. This variable is accessible to users by passing /usescancodes:1 as a launch option. FNA_GAMEPAD_NUM_GAMEPADS XNA4 supports four controllers, per XInput's limitations. However, SDL gives us the ability to support more controllers when available. You can set this environment variable on/before program startup to set a controller count without modifying FNA: Environment.SetEnvironmentVariable(\"FNA_GAMEPAD_NUM_GAMEPADS\", \"8\"); FNA_SDL_FORCE_BASE_PATH For the desktop, we use AppDomain.CurrentDomain.BaseDirectory as the root path, as this is more accurate on platforms where the \"real\" EXE path is the path of the CLR. However, there may be some scenarios even on desktop where SDL_GetBasePath() is more appropriate. If you want to override our defaults, this variable can be set on startup. FNA3D_FORCE_DRIVER FNA3D supports multiple graphics backends with a single binary. Sometimes the default may not produce the optimal result for specific hardware, or a backend may exhibit graphics driver bugs that are not present in other backends. The list of available driver strings for this environment variable is as follows, in order of the current default priority: SDL_GPU (Vulkan, Metal, D3D12) D3D11 OpenGL This variable is accessible to users by passing /gldevice:%s as a launch option, where %s can be one of the above strings. Note that the string must match an available driver exactly , or device creation will fail! FNA3D_ENABLE_HDR_COLORSPACE The XNA specification includes multiple surface formats capable of using an HDR colorspace - however, all rendering is assumed to be standard sRGB. Applications can set this variable to \"1\" to enable support for creating swapchains with the HDR10 (Rgba1010102) and extended sRGB (HalfVector4/HdrBlendable) colorspaces. Note that this only exposes the ability to set the colorspace of the swapchain and nothing else - any and all colorspace conversion still has to be done by the application. Additionally, be careful when adding user-facing support for HDR; it should be treated as the equivalent of a full kernel modeset, so it is very expensive and fragile to attempt anywhere except on startup! This feature is only supported on Vulkan and D3D11. FNA3D_ENABLE_LATESWAPTEAR For many years FNA would default to using FIFO_RELAXED / EXT_swap_control_tear VSync to improve performance when games temporarily performed below the display's refresh rate. However, in recent years this has fallen out of fashion; most platforms don't support this feature at all and the platforms that did support it have opted to avoid presentation systems that involve tearing at all (in favor of other systems like \"mailbox\" presentation). Additionally, refresh rates have rapidly become unstandardized within the last hardware generation, so fixed-rate games would see tearing if the game rate was below the refresh rate of the monitor. Some may still want to try using the late swap tear feature with their OS/driver/display combo, however, so users can set this to \"1\" if they'd like. This variable is also accessible to users by passing /enablelateswaptear:1 as a launch option. FNA3D_MOJOSHADER_PROFILE FNA3D uses MojoShader to support XNA4 (D3D9) Effect shader binaries. One major benefit of MojoShader is that it supports multiple shader profiles, including GLSL and SPIR-V. By default, each renderer picks the most appropriate shader profile by itself, but you can set this variable to forcibly use a specific profile. Unless you're a developer working on a new shader profile, this is probably useless to you. This variable is accessible to users by passing /mojoshaderprofile:%s as a launch option, where %s can be glsl120 or glspirv . Currently this is only useful for OpenGL. FNA3D_BACKBUFFER_SCALE_NEAREST When using the faux-backbuffer, we use a linear filter to blit to the window's backbuffer. However, some games may prefer to use a point/nearest-neighbor filter to scale in specific scenarios (such as pixel art games running in multiples of the desktop resolution). To use that filter instead, set this variable to \"1\" before running the game. This variable is accessible to users by passing /backbufferscalenearest:1 as a launch option. FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT OpenGL contexts are very clunky and require the RGB/Depth/Stencil sizes at window creation time rather than context creation time, and cannot be reset without destroying the window and GL context. By default we play it safe and create a window with a Depth24Stencil8 backbuffer, but if you want to optimize on this you can set this environment variable to a DepthFormat enum value at program startup to override our settings. For example: SDL3.SDL.SDL_SetHintWithPriority( \"FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT\", \"None\", SDL3.SDL.SDL_HintPriority.SDL_HINT_OVERRIDE ); Note, however, that the OS may completely ignore your settings and pick whatever it wants for its window backbuffer format. (This is rare, but it's still a nonzero chance...) FNA3D_OPENGL_FORCE_ES3 FNA3D has support for OpenGL ES 3.0. Formerly used for iOS/tvOS, it is also known to work with Google's ANGLE project (D3D11 only) and, to some extent, some Android hardware. This may also be useful to those that would like to try to port to new ES platforms (WebAssembly, Android, etc.). Simply set this to \"1\" on startup and an ES context will be used instead of a desktop context. This variable is accessible to users by passing /glprofile:es3 as a launch option. FNA3D_OPENGL_FORCE_CORE_PROFILE FNA3D currently aims for OpenGL 2.1 with a handful of ARB extensions for features like multisampling, hardware instancing, and so on. However, we are also capable of targeting the OpenGL 4.6 Core Profile, with a small handful of mostly-harmless changes. RenderDoc requires this to capture frames; set this variable to \"1\" in the capture GUI before launching to successfully capture frames. While this does enable Core Profile features, note that we still do what your engine tells us to do. For example, even though client-side vertex/index data is forbidden, we still still attempt to render as such, and ARB_debug_output as well as the RenderDoc capturing system will throw errors (and possibly crash) because you are not using buffer objects. Note that this is probably useless in every situation other than accommodating graphics debuggers. This variable is accessible to users by passing /glprofile:core as a launch option. FNA3D_OPENGL_FORCE_COMPATIBILITY_PROFILE Some devices (i.e. NVIDIA Tegra) will default to either an OpenGL ES context or a modern OpenGL context that is incompatible with certain legacy OpenGL features. However, sometimes those devices will support the context version that FNA3D tries to aim for, so this variable exists to let developers attempt a 2.1 Compatibility context for those situations. That said, if your device wants a context version that your data isn't compatible with, try fixing the data at some point! This variable is accessible to users by passing /glprofile:compatibility as a launch option.","title":"7: FNA Environment Variables"},{"location":"7%3A-FNA-Environment-Variables/#7-fna-environment-variables","text":"FNA will check for certain environment variables to perform certain tasks in a non-default manner. For the most part these are meant to be used by both developers and customers, but there are also cases where we use environment variables as a means of working around a specific problem without requiring a build-time option/configuration. NOTE: .NET Core intentionally broke native library compatibility with System.Environment.SetEnvironmentVariable , so for any FNA3D environment variables, we recommend using SDL_SetHint instead, even though this will have to be updated when SDL3 is released. The documentation below uses this function, if you need an example. (You are of course welcome to continue using .NET Framework and Mono instead, which does not have this issue.) FNA: FNA_GRAPHICS_ENABLE_HIGHDPI FNA_GRAPHICS_JPEG_SAVE_QUALITY FNA_KEYBOARD_USE_SCANCODES FNA_GAMEPAD_NUM_GAMEPADS FNA_SDL_FORCE_BASE_PATH FNA3D: FNA3D_FORCE_DRIVER FNA3D_ENABLE_HDR_COLORSPACE FNA3D_ENABLE_LATESWAPTEAR FNA3D_MOJOSHADER_PROFILE FNA3D_BACKBUFFER_SCALE_NEAREST FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT FNA3D_OPENGL_FORCE_ES3 FNA3D_OPENGL_FORCE_CORE_PROFILE FNA3D_OPENGL_FORCE_COMPATIBILITY_PROFILE","title":"7: FNA Environment Variables"},{"location":"7%3A-FNA-Environment-Variables/#fna_graphics_enable_highdpi","text":"While many modern displays are capable of much higher DPIs (such as \"Retina\" displays on macOS and iOS), XNA does not have any mechanism for supporting high-DPI rendering. Enabling this feature is as simple as setting this before creating your Game: Environment.SetEnvironmentVariable(\"FNA_GRAPHICS_ENABLE_HIGHDPI\", \"1\"); After calling your Game constructor, you can then check to see if high-DPI creation was successful: Settings.HighDPI = Environment.GetEnvironmentVariable(\"FNA_GRAPHICS_ENABLE_HIGHDPI\") == \"1\"; While it is possible for us to create windows with high-DPI drawing space, we cannot guarantee that it will be available at all times. Worse, we can only acquire this feature on startup, so toggling high-DPI mode will require restarting your game. When this is enabled, the drawable size will take priority over the window size. So, when running at 1920x1080 in windowed mode, the drawable size will be 1920x1080, but the window size will be 960x540. This allows users to set the game resolution to the maximum resolution allowed by the OS while having the appropriate window size. In fullscreen mode we will continue to run at the desktop resolution with a faux-backbuffer for non-native resolutions, but in high-DPI mode the native resolution will now be the actual native resolution rather than the simulated resolution. As always, be sure that your RenderTargets and Viewports match the backbuffer size and NOT the window size! Lastly, when packaging for macOS, be sure this is in your app bundle's Info.plist: <key>NSHighResolutionCapable</key> <string>True</string> This variable is accessible to users by passing /enablehighdpi:1 as a launch option.","title":"FNA_GRAPHICS_ENABLE_HIGHDPI"},{"location":"7%3A-FNA-Environment-Variables/#fna_graphics_jpeg_save_quality","text":"For some reason they didn't expose a quality parameter to SaveAsJpeg, so we added one ourselves! This variable is checked each time you call the function, so feel free to customize this based on the context for each time you save an image. The value is expected to be between 1 and 100.","title":"FNA_GRAPHICS_JPEG_SAVE_QUALITY"},{"location":"7%3A-FNA-Environment-Variables/#fna_keyboard_use_scancodes","text":"XNA keys are based on keycodes, rather than scancodes. With SDL, for example, you can actually pick between SDL_Keycode and SDL_Scancode, but scancodes will not be accurate to XNA4. The benefit is that scancodes will ignore \"foreign\" keyboard layouts, making default keyboard layouts work out of the box everywhere (unless the actual symbol for the keys matters in your game). While FNA provides the GetKeyFromScancodeEXT extension and developers are encouraged to use it, this is not a required function and users may benefit from this environment variable in the event that layouts are not checked in-game. In either case, TextInputEXT will still read the actual chars correctly, so you can (mostly) have your cake and eat it too if you don't care about your bindings menu not making a lot of sense on foreign layouts. To use scancodes instead of keycodes, set this variable to \"1\" before starting the game. This variable is accessible to users by passing /usescancodes:1 as a launch option.","title":"FNA_KEYBOARD_USE_SCANCODES"},{"location":"7%3A-FNA-Environment-Variables/#fna_gamepad_num_gamepads","text":"XNA4 supports four controllers, per XInput's limitations. However, SDL gives us the ability to support more controllers when available. You can set this environment variable on/before program startup to set a controller count without modifying FNA: Environment.SetEnvironmentVariable(\"FNA_GAMEPAD_NUM_GAMEPADS\", \"8\");","title":"FNA_GAMEPAD_NUM_GAMEPADS"},{"location":"7%3A-FNA-Environment-Variables/#fna_sdl_force_base_path","text":"For the desktop, we use AppDomain.CurrentDomain.BaseDirectory as the root path, as this is more accurate on platforms where the \"real\" EXE path is the path of the CLR. However, there may be some scenarios even on desktop where SDL_GetBasePath() is more appropriate. If you want to override our defaults, this variable can be set on startup.","title":"FNA_SDL_FORCE_BASE_PATH"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_force_driver","text":"FNA3D supports multiple graphics backends with a single binary. Sometimes the default may not produce the optimal result for specific hardware, or a backend may exhibit graphics driver bugs that are not present in other backends. The list of available driver strings for this environment variable is as follows, in order of the current default priority: SDL_GPU (Vulkan, Metal, D3D12) D3D11 OpenGL This variable is accessible to users by passing /gldevice:%s as a launch option, where %s can be one of the above strings. Note that the string must match an available driver exactly , or device creation will fail!","title":"FNA3D_FORCE_DRIVER"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_enable_hdr_colorspace","text":"The XNA specification includes multiple surface formats capable of using an HDR colorspace - however, all rendering is assumed to be standard sRGB. Applications can set this variable to \"1\" to enable support for creating swapchains with the HDR10 (Rgba1010102) and extended sRGB (HalfVector4/HdrBlendable) colorspaces. Note that this only exposes the ability to set the colorspace of the swapchain and nothing else - any and all colorspace conversion still has to be done by the application. Additionally, be careful when adding user-facing support for HDR; it should be treated as the equivalent of a full kernel modeset, so it is very expensive and fragile to attempt anywhere except on startup! This feature is only supported on Vulkan and D3D11.","title":"FNA3D_ENABLE_HDR_COLORSPACE"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_enable_lateswaptear","text":"For many years FNA would default to using FIFO_RELAXED / EXT_swap_control_tear VSync to improve performance when games temporarily performed below the display's refresh rate. However, in recent years this has fallen out of fashion; most platforms don't support this feature at all and the platforms that did support it have opted to avoid presentation systems that involve tearing at all (in favor of other systems like \"mailbox\" presentation). Additionally, refresh rates have rapidly become unstandardized within the last hardware generation, so fixed-rate games would see tearing if the game rate was below the refresh rate of the monitor. Some may still want to try using the late swap tear feature with their OS/driver/display combo, however, so users can set this to \"1\" if they'd like. This variable is also accessible to users by passing /enablelateswaptear:1 as a launch option.","title":"FNA3D_ENABLE_LATESWAPTEAR"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_mojoshader_profile","text":"FNA3D uses MojoShader to support XNA4 (D3D9) Effect shader binaries. One major benefit of MojoShader is that it supports multiple shader profiles, including GLSL and SPIR-V. By default, each renderer picks the most appropriate shader profile by itself, but you can set this variable to forcibly use a specific profile. Unless you're a developer working on a new shader profile, this is probably useless to you. This variable is accessible to users by passing /mojoshaderprofile:%s as a launch option, where %s can be glsl120 or glspirv . Currently this is only useful for OpenGL.","title":"FNA3D_MOJOSHADER_PROFILE"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_backbuffer_scale_nearest","text":"When using the faux-backbuffer, we use a linear filter to blit to the window's backbuffer. However, some games may prefer to use a point/nearest-neighbor filter to scale in specific scenarios (such as pixel art games running in multiples of the desktop resolution). To use that filter instead, set this variable to \"1\" before running the game. This variable is accessible to users by passing /backbufferscalenearest:1 as a launch option.","title":"FNA3D_BACKBUFFER_SCALE_NEAREST"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_opengl_window_depthstencilformat","text":"OpenGL contexts are very clunky and require the RGB/Depth/Stencil sizes at window creation time rather than context creation time, and cannot be reset without destroying the window and GL context. By default we play it safe and create a window with a Depth24Stencil8 backbuffer, but if you want to optimize on this you can set this environment variable to a DepthFormat enum value at program startup to override our settings. For example: SDL3.SDL.SDL_SetHintWithPriority( \"FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT\", \"None\", SDL3.SDL.SDL_HintPriority.SDL_HINT_OVERRIDE ); Note, however, that the OS may completely ignore your settings and pick whatever it wants for its window backbuffer format. (This is rare, but it's still a nonzero chance...)","title":"FNA3D_OPENGL_WINDOW_DEPTHSTENCILFORMAT"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_opengl_force_es3","text":"FNA3D has support for OpenGL ES 3.0. Formerly used for iOS/tvOS, it is also known to work with Google's ANGLE project (D3D11 only) and, to some extent, some Android hardware. This may also be useful to those that would like to try to port to new ES platforms (WebAssembly, Android, etc.). Simply set this to \"1\" on startup and an ES context will be used instead of a desktop context. This variable is accessible to users by passing /glprofile:es3 as a launch option.","title":"FNA3D_OPENGL_FORCE_ES3"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_opengl_force_core_profile","text":"FNA3D currently aims for OpenGL 2.1 with a handful of ARB extensions for features like multisampling, hardware instancing, and so on. However, we are also capable of targeting the OpenGL 4.6 Core Profile, with a small handful of mostly-harmless changes. RenderDoc requires this to capture frames; set this variable to \"1\" in the capture GUI before launching to successfully capture frames. While this does enable Core Profile features, note that we still do what your engine tells us to do. For example, even though client-side vertex/index data is forbidden, we still still attempt to render as such, and ARB_debug_output as well as the RenderDoc capturing system will throw errors (and possibly crash) because you are not using buffer objects. Note that this is probably useless in every situation other than accommodating graphics debuggers. This variable is accessible to users by passing /glprofile:core as a launch option.","title":"FNA3D_OPENGL_FORCE_CORE_PROFILE"},{"location":"7%3A-FNA-Environment-Variables/#fna3d_opengl_force_compatibility_profile","text":"Some devices (i.e. NVIDIA Tegra) will default to either an OpenGL ES context or a modern OpenGL context that is incompatible with certain legacy OpenGL features. However, sometimes those devices will support the context version that FNA3D tries to aim for, so this variable exists to let developers attempt a 2.1 Compatibility context for those situations. That said, if your device wants a context version that your data isn't compatible with, try fixing the data at some point! This variable is accessible to users by passing /glprofile:compatibility as a launch option.","title":"FNA3D_OPENGL_FORCE_COMPATIBILITY_PROFILE"},{"location":"8%3A-Contributing-to-FNA/","text":"8: Contributing to FNA This is a rough guide for contributing to FNA. This should NOT be considered the be-all-end-all rulebook for FNA development, but it contains some basic examples of how the project is written and developed. In general, Rule #0 is simply to use your best judgement based on existing traditions in the code and its libraries. Forks GitHub makes forking as easy as clicking a button. Here's when to click that button: When you're about to commit a patch Do NOT clutter up the network with pointless forks! Either write something or just use our repository. We promise that the clone that you have locally on your machine will never be forcibly updated by us unless you explicitly type git pull (that's how Git works!), and we will always have stable releases archived . The network graph is critical for tracking developers' changes, if too many forks exist then the feature is forcibly turned off by GitHub! Code Style Line Endings: Unix newlines ('\\n'), NOT Win32 newlines ('\\r\\n')! Tabs: Actual '\\t' tabs, NOT SPACES! Blank Lines: NO TRAILING SPACE! Blank lines should be, you know, blank. Characters per line: ~100. When a line gets too long, start splitting it up into multiple lines. The number should only be considered a maximum value; if you find that you're doing a lot of extensive left-to-right reading rather than top-to-bottom, start splitting the lines up. i++/i-- : Do i += 1 and i -= 1 instead unless the increment is genuinely being used to its advantage. If it's that painful to do this, consider foreach instead. Do NOT use var ! Use the actual type name! someMethod() rather than someMethod () , someArray[x] rather than someArray [x] , etc. (Type) cast rather than (Type)cast . Use braces everywhere! I don't care if the if block is one line, braces! Use them! Single line comments: // This code is derp rather than //this code is derp . Multi-line comments: Use /* */ blocks, rather than multiple lines of // . External Libraries As noted in the download documentation , we use several third-party libraries to support FNA. A major rule for FNA is that we do NOT fork external libraries! Anything we change must be submitted to upstream, and must be of high enough quality to be merged. FNA's role is solely to reimplement XNA, nothing further. Any issue exhibited by the libraries must be fixed in the library for the benefit of the greater software ecosystem. The sources can be found here: SDL FNA3D FAudio Theorafile All libraries are built with the default settings.","title":"8: Contributing to FNA"},{"location":"8%3A-Contributing-to-FNA/#8-contributing-to-fna","text":"This is a rough guide for contributing to FNA. This should NOT be considered the be-all-end-all rulebook for FNA development, but it contains some basic examples of how the project is written and developed. In general, Rule #0 is simply to use your best judgement based on existing traditions in the code and its libraries.","title":"8: Contributing to FNA"},{"location":"8%3A-Contributing-to-FNA/#forks","text":"GitHub makes forking as easy as clicking a button. Here's when to click that button: When you're about to commit a patch Do NOT clutter up the network with pointless forks! Either write something or just use our repository. We promise that the clone that you have locally on your machine will never be forcibly updated by us unless you explicitly type git pull (that's how Git works!), and we will always have stable releases archived . The network graph is critical for tracking developers' changes, if too many forks exist then the feature is forcibly turned off by GitHub!","title":"Forks"},{"location":"8%3A-Contributing-to-FNA/#code-style","text":"Line Endings: Unix newlines ('\\n'), NOT Win32 newlines ('\\r\\n')! Tabs: Actual '\\t' tabs, NOT SPACES! Blank Lines: NO TRAILING SPACE! Blank lines should be, you know, blank. Characters per line: ~100. When a line gets too long, start splitting it up into multiple lines. The number should only be considered a maximum value; if you find that you're doing a lot of extensive left-to-right reading rather than top-to-bottom, start splitting the lines up. i++/i-- : Do i += 1 and i -= 1 instead unless the increment is genuinely being used to its advantage. If it's that painful to do this, consider foreach instead. Do NOT use var ! Use the actual type name! someMethod() rather than someMethod () , someArray[x] rather than someArray [x] , etc. (Type) cast rather than (Type)cast . Use braces everywhere! I don't care if the if block is one line, braces! Use them! Single line comments: // This code is derp rather than //this code is derp . Multi-line comments: Use /* */ blocks, rather than multiple lines of // .","title":"Code Style"},{"location":"8%3A-Contributing-to-FNA/#external-libraries","text":"As noted in the download documentation , we use several third-party libraries to support FNA. A major rule for FNA is that we do NOT fork external libraries! Anything we change must be submitted to upstream, and must be of high enough quality to be merged. FNA's role is solely to reimplement XNA, nothing further. Any issue exhibited by the libraries must be fixed in the library for the benefit of the greater software ecosystem. The sources can be found here: SDL FNA3D FAudio Theorafile All libraries are built with the default settings.","title":"External Libraries"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/","text":"Appendix A: NativeAOT on PC FNA now has support for NativeAOT , a new .NET toolchain which allows you to build your game into an ahead-of-time compiled native executable. Project Setup To get started, please read through the official NativeAOT documentation . Make sure to install the prerequisites listed for your OS. To make a NativeAOT build, you should make .NET 8 project files for your game - instead of the usual FNA.csproj, you will reference FNA.Core.csproj. The code and content should largely be able to stay the same, with the exception of code that requires a JIT (i.e. you can't emit IL at runtime, as you might expect from ahead-of-time compilation). To make your .csproj compatible with NativeAOT, add the following: <PropertyGroup> <PublishAot>true</PublishAot> </PropertyGroup> <ItemGroup> <RdXmlFile Include=\"rd.xml\" /> </ItemGroup> <ItemGroup Condition=\"'$(OS)' != 'Windows_NT'\"> <NativeLibrary Include=\"-lSDL3\" /> <NativeLibrary Include=\"-lFNA3D\" /> <NativeLibrary Include=\"-lFAudio\" /> <NativeLibrary Include=\"-ltheorafile\" /> </ItemGroup> <ItemGroup Condition=\"'$(OS)' == 'Windows_NT'\"> <NativeLibrary Include=\"SDL3.lib\" /> <NativeLibrary Include=\"FNA3D.lib\" /> <NativeLibrary Include=\"FAudio.lib\" /> <NativeLibrary Include=\"libtheorafile.lib\" /> </ItemGroup> <ItemGroup> <DirectPInvoke Include=\"SDL3\" /> <DirectPInvoke Include=\"FNA3D\" /> <DirectPInvoke Include=\"FAudio\" /> <DirectPInvoke Include=\"libtheorafile\" /> </ItemGroup> You will also need to add an \"rd.xml\" file to your project directory. This will be explained in the next sections. AOT Type Preservation The rd.xml file informs the compiler of any types it should preserve during the linking stage. This is most often used to preserve types that are only accessed via reflection. You can read the official doc page to learn more about it, but here's an example of what rd.xml might look like for a game that uses ContentReader to load a couple of generic types: <Directives> <Application> <Assembly Name=\"FNA\"> <Type Name=\"Microsoft.Xna.Framework.Content.ListReader`1[[System.Char,mscorlib]]\" Dynamic=\"Required All\" /> <Type Name=\"Microsoft.Xna.Framework.Content.ArrayReader`1[[Microsoft.Xna.Framework.Vector3,FNA]]\" Dynamic=\"Required All\" /> </Assembly> <Assembly Name=\"mscorlib\" /> </Application> </Directives> Native Libraries Even though we're AOT-compiling the project, we still recommend dynamically linking the native libraries rather than statically linking them. Note that this does not mean dynamic loading; the NativeLibrary and DirectPInvoke items in the .csproj ensure that native calls are inlined directly into the executable, rather than requiring a dlopen call to load the library at runtime. This is more performant and reliable than the standard .NET PInvoke system, and is only possible with AOT. Finally, to actually link the fnalibs, we need to set up the build environment appropriately: Windows Download the MSVC development build of SDL3, then use it to build the other libraries from source. Grab the .lib files from SDL3, FNA3D, FAudio, and Theorafile and place them in your app's .csproj directory. Build the application. Copy the contents of fnalibs/x64 into the generated output directory. Linux Linux builds are best done in a Steam Linux Runtime container, which can be done both locally and via CI (including GitHub Actions). # Set up image for the first time distrobox create -i registry.gitlab.steamos.cloud/steamrt/sniper/sdk sniper # Start up the container. It's as easy as that! distrobox enter sniper Inside the container you will want to install the .NET SDK and the fnalibs: wget https://packages.microsoft.com/config/debian/11/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt-get update && sudo apt-get install -y dotnet-sdk-8.0 rm packages-microsoft-prod.deb git clone --recursive https://github.com/FNA-XNA/FAudio.git git clone --recursive https://github.com/FNA-XNA/FNA3D.git git clone --recursive https://github.com/FNA-XNA/Theorafile.git cd FAudio cmake -B release -G Ninja . -DCMAKE_BUILD_TYPE=Release sudo ninja -C release install cd ../FNA3D cmake -B release -G Ninja . -DCMAKE_BUILD_TYPE=Release sudo ninja -C release install cd ../Theorafile make sudo cp libtheorafile.so /usr/local/lib/libtheorafile.so Once the above is complete, dotnet publish should build and link a native Linux build. Copy the fnalibs next to the executable and ship! cp /usr/local/lib/libFAudio.so.0 bin/Release/net8.0/linux-x64/publish/ cp /usr/local/lib/libFNA3D.so.0 bin/Release/net8.0/linux-x64/publish/ cp /usr/local/lib/libtheorafile.so bin/Release/net8.0/linux-x64/publish/ Note that these instructions do not copy SDL3; this is already provided by the Sniper runtime so bundling SDL is optional. If you need to bundle it anyway, be sure to use the binaries provided by fnalibs-dailies instead! You can see an example of an automated CI build here .","title":"Appendix A: NativeAOT on PC"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#appendix-a-nativeaot-on-pc","text":"FNA now has support for NativeAOT , a new .NET toolchain which allows you to build your game into an ahead-of-time compiled native executable.","title":"Appendix A: NativeAOT on PC"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#project-setup","text":"To get started, please read through the official NativeAOT documentation . Make sure to install the prerequisites listed for your OS. To make a NativeAOT build, you should make .NET 8 project files for your game - instead of the usual FNA.csproj, you will reference FNA.Core.csproj. The code and content should largely be able to stay the same, with the exception of code that requires a JIT (i.e. you can't emit IL at runtime, as you might expect from ahead-of-time compilation). To make your .csproj compatible with NativeAOT, add the following: <PropertyGroup> <PublishAot>true</PublishAot> </PropertyGroup> <ItemGroup> <RdXmlFile Include=\"rd.xml\" /> </ItemGroup> <ItemGroup Condition=\"'$(OS)' != 'Windows_NT'\"> <NativeLibrary Include=\"-lSDL3\" /> <NativeLibrary Include=\"-lFNA3D\" /> <NativeLibrary Include=\"-lFAudio\" /> <NativeLibrary Include=\"-ltheorafile\" /> </ItemGroup> <ItemGroup Condition=\"'$(OS)' == 'Windows_NT'\"> <NativeLibrary Include=\"SDL3.lib\" /> <NativeLibrary Include=\"FNA3D.lib\" /> <NativeLibrary Include=\"FAudio.lib\" /> <NativeLibrary Include=\"libtheorafile.lib\" /> </ItemGroup> <ItemGroup> <DirectPInvoke Include=\"SDL3\" /> <DirectPInvoke Include=\"FNA3D\" /> <DirectPInvoke Include=\"FAudio\" /> <DirectPInvoke Include=\"libtheorafile\" /> </ItemGroup> You will also need to add an \"rd.xml\" file to your project directory. This will be explained in the next sections.","title":"Project Setup"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#aot-type-preservation","text":"The rd.xml file informs the compiler of any types it should preserve during the linking stage. This is most often used to preserve types that are only accessed via reflection. You can read the official doc page to learn more about it, but here's an example of what rd.xml might look like for a game that uses ContentReader to load a couple of generic types: <Directives> <Application> <Assembly Name=\"FNA\"> <Type Name=\"Microsoft.Xna.Framework.Content.ListReader`1[[System.Char,mscorlib]]\" Dynamic=\"Required All\" /> <Type Name=\"Microsoft.Xna.Framework.Content.ArrayReader`1[[Microsoft.Xna.Framework.Vector3,FNA]]\" Dynamic=\"Required All\" /> </Assembly> <Assembly Name=\"mscorlib\" /> </Application> </Directives>","title":"AOT Type Preservation"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#native-libraries","text":"Even though we're AOT-compiling the project, we still recommend dynamically linking the native libraries rather than statically linking them. Note that this does not mean dynamic loading; the NativeLibrary and DirectPInvoke items in the .csproj ensure that native calls are inlined directly into the executable, rather than requiring a dlopen call to load the library at runtime. This is more performant and reliable than the standard .NET PInvoke system, and is only possible with AOT. Finally, to actually link the fnalibs, we need to set up the build environment appropriately:","title":"Native Libraries"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#windows","text":"Download the MSVC development build of SDL3, then use it to build the other libraries from source. Grab the .lib files from SDL3, FNA3D, FAudio, and Theorafile and place them in your app's .csproj directory. Build the application. Copy the contents of fnalibs/x64 into the generated output directory.","title":"Windows"},{"location":"appendix/Appendix-A%3A-NativeAOT-on-PC/#linux","text":"Linux builds are best done in a Steam Linux Runtime container, which can be done both locally and via CI (including GitHub Actions). # Set up image for the first time distrobox create -i registry.gitlab.steamos.cloud/steamrt/sniper/sdk sniper # Start up the container. It's as easy as that! distrobox enter sniper Inside the container you will want to install the .NET SDK and the fnalibs: wget https://packages.microsoft.com/config/debian/11/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt-get update && sudo apt-get install -y dotnet-sdk-8.0 rm packages-microsoft-prod.deb git clone --recursive https://github.com/FNA-XNA/FAudio.git git clone --recursive https://github.com/FNA-XNA/FNA3D.git git clone --recursive https://github.com/FNA-XNA/Theorafile.git cd FAudio cmake -B release -G Ninja . -DCMAKE_BUILD_TYPE=Release sudo ninja -C release install cd ../FNA3D cmake -B release -G Ninja . -DCMAKE_BUILD_TYPE=Release sudo ninja -C release install cd ../Theorafile make sudo cp libtheorafile.so /usr/local/lib/libtheorafile.so Once the above is complete, dotnet publish should build and link a native Linux build. Copy the fnalibs next to the executable and ship! cp /usr/local/lib/libFAudio.so.0 bin/Release/net8.0/linux-x64/publish/ cp /usr/local/lib/libFNA3D.so.0 bin/Release/net8.0/linux-x64/publish/ cp /usr/local/lib/libtheorafile.so bin/Release/net8.0/linux-x64/publish/ Note that these instructions do not copy SDL3; this is already provided by the Sniper runtime so bundling SDL is optional. If you need to bundle it anyway, be sure to use the binaries provided by fnalibs-dailies instead! You can see an example of an automated CI build here .","title":"Linux"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/","text":"Appendix B: FNA on Consoles FNA supports deploying to consoles via NativeAOT. FNA does not have any private branches for each platform; the public master branch of FNA is exactly what is used to ship for these targets. The platform code is contained entirely in SDL and the NativeAOT bootstrap. General Advice While the runtimes require a console NDA, there are some things you can do to make your game more robust that just-so-happens to make console support easier, without access to any particular SDK. If you're familiar with consoles, none of these will be surprising: NativeAOT All console builds use NativeAOT as the runtime. If you want a solid head-start, you should read Appendix A. Don't underestimate this step, especially if your game heavily depends on .NET's reflection features! Bootstrapping For non-PC builds it is generally a good idea to assume that platform-specific bootstrapping is needed - in FNA's case we make use of SDL3's SDL_RunApp functionality; your code should be able to stay the same except for the Main function: [STAThread] static void Main(string[] args) #if NET { realArgs = args; SDL3.SDL.SDL_main_func mainFunction = FakeMain; SDL3.SDL.SDL_RunApp(0, IntPtr.Zero, mainFunction, IntPtr.Zero); } static string[] realArgs; static int FakeMain(int argc, IntPtr argv) { RealMain(realArgs); return 0; } static void RealMain(string[] args) #endif { // blah blah blah } Window Size Changes Even if your window is not resizable, operating systems (including Windows!) may forcibly change the window size for a multitude of reasons, and so the graphics device will reset. Consider the following code: void ApplyVideoSettings(int width, int height, bool fullscreen, bool vsync); { // Update GraphicsDeviceManager... graphics.PreferredBackBufferWidth = width; graphics.PreferredBackBufferHeight = height; graphics.SynchronizeWithVerticalRetrace = vsync; graphics.IsFullScreen = fullscreen; // Apply! graphics.ApplyChanges(); // A bunch of engine stuff menu.ResizeScreen(); renderer.RecreateRenderTargets(); } This is actually kind of wrong; even in fullscreen mode it is possible for the operating system to affect your window size and break your game. But you don't need to go through a bunch of trouble to support AllowUserResizing or anything like that, as XNA internally hooks up ClientSizeChanged to GraphicsDeviceManager.ApplyChanges() , which should lead to a reset that you can catch with GraphicsDeviceManager.DeviceReset events: public MyGame() : base() { graphics = new GraphicsDeviceManager(this); graphics.DeviceCreated += OnDeviceCreated; graphics.DeviceReset += OnDeviceReset; } private void OnDeviceCreated(object sender, EventArgs e) { // A bunch of engine size stuff before Initialize() } private void OnDeviceReset(object sender, EventArgs e) { // A bunch of engine stuff menu.ResizeScreen(); renderer.RecreateRenderTargets(); } void ApplyVideoSettings(int width, int height, bool fullscreen, bool vsync); { // Update GraphicsDeviceManager... graphics.PreferredBackBufferWidth = width; graphics.PreferredBackBufferHeight = height; graphics.SynchronizeWithVerticalRetrace = vsync; graphics.IsFullScreen = fullscreen; // Apply! graphics.ApplyChanges(); // A bunch of engine stuff used to be here. It's gone now. } Even if you do not support resizable windows, you need to be prepared for resizes to happen at absolutely any time in your program. Filesystem Portability (Again) Unless you're working with savedata, using System.IO.File is highly discouraged. (And even then, savedata was supposed to be done with Microsoft.Xna.Framework.Storage in the XBLIG world). If you're loading files with File.Open specifically, your game may not even work on PC because the player may have the game installed in a location without write permissions! To load files, use TitleContainer.OpenStream instead. We actually do not recommend Microsoft.Xna.Framework.Storage ; instead you should use SDL3's Storage API (this is provided in our included C# bindings). If you already have established savedata out in the wild, isolate your filesystem calls as much as possible. Lord knows how many times I've done this to make Linux savedata not go directly in $HOME ... Xbox GDK Our GDK support is now 100% public source code! Once you have signed the GDK Agreement with Microsoft and have installed the Xbox GDK you can start with the NativeAOT repository . Additionally, developers can request access to our #xbox Discord channel once they join both the FNA and ID@Xbox Discord servers. Nintendo Switch While there is no special code needed for Nintendo Switch support (100% of the platform code is in SDL and NativeAOT, two separate projects), all consulting and documentation is private, per NDA requirements. If you are a licensed developer, please get access to SDL-switch (search the licensee forums) and then get in touch with flibit on Discord. If you are NOT a licensed developer, you're on your own. None of us are able to get you hooked up, so please only get in touch AFTER you have Switch SDK access. PlayStation While there is no special code needed for PS5 support (100% of the platform code is in SDL and NativeAOT, two separate projects), all consulting and documentation is private, per NDA requirements. If you are a licensed developer, please get access to SDL-playstation (contact Ryan C. Gordon for this) and then get in touch with flibit on Discord. If you are NOT a licensed developer, you're on your own. None of us are able to get you hooked up, so please only get in touch AFTER you have PlayStation SDK access. One detail we can share is that shaders must be precompiled ahead of time; as a result you will need to preprocess your Effect shaders (but you can continue to use the binaries as-is - no, really!). The best way to do this is to make an FNA3D trace of a complete playthrough of your game, then dump SPIR-V binaries with FNA3D's dumping tool . These SPIR-V modules will come in handy to create a working PlayStation renderer.","title":"Appendix B: FNA on Consoles"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#appendix-b-fna-on-consoles","text":"FNA supports deploying to consoles via NativeAOT. FNA does not have any private branches for each platform; the public master branch of FNA is exactly what is used to ship for these targets. The platform code is contained entirely in SDL and the NativeAOT bootstrap.","title":"Appendix B: FNA on Consoles"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#general-advice","text":"While the runtimes require a console NDA, there are some things you can do to make your game more robust that just-so-happens to make console support easier, without access to any particular SDK. If you're familiar with consoles, none of these will be surprising:","title":"General Advice"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#nativeaot","text":"All console builds use NativeAOT as the runtime. If you want a solid head-start, you should read Appendix A. Don't underestimate this step, especially if your game heavily depends on .NET's reflection features!","title":"NativeAOT"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#bootstrapping","text":"For non-PC builds it is generally a good idea to assume that platform-specific bootstrapping is needed - in FNA's case we make use of SDL3's SDL_RunApp functionality; your code should be able to stay the same except for the Main function: [STAThread] static void Main(string[] args) #if NET { realArgs = args; SDL3.SDL.SDL_main_func mainFunction = FakeMain; SDL3.SDL.SDL_RunApp(0, IntPtr.Zero, mainFunction, IntPtr.Zero); } static string[] realArgs; static int FakeMain(int argc, IntPtr argv) { RealMain(realArgs); return 0; } static void RealMain(string[] args) #endif { // blah blah blah }","title":"Bootstrapping"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#window-size-changes","text":"Even if your window is not resizable, operating systems (including Windows!) may forcibly change the window size for a multitude of reasons, and so the graphics device will reset. Consider the following code: void ApplyVideoSettings(int width, int height, bool fullscreen, bool vsync); { // Update GraphicsDeviceManager... graphics.PreferredBackBufferWidth = width; graphics.PreferredBackBufferHeight = height; graphics.SynchronizeWithVerticalRetrace = vsync; graphics.IsFullScreen = fullscreen; // Apply! graphics.ApplyChanges(); // A bunch of engine stuff menu.ResizeScreen(); renderer.RecreateRenderTargets(); } This is actually kind of wrong; even in fullscreen mode it is possible for the operating system to affect your window size and break your game. But you don't need to go through a bunch of trouble to support AllowUserResizing or anything like that, as XNA internally hooks up ClientSizeChanged to GraphicsDeviceManager.ApplyChanges() , which should lead to a reset that you can catch with GraphicsDeviceManager.DeviceReset events: public MyGame() : base() { graphics = new GraphicsDeviceManager(this); graphics.DeviceCreated += OnDeviceCreated; graphics.DeviceReset += OnDeviceReset; } private void OnDeviceCreated(object sender, EventArgs e) { // A bunch of engine size stuff before Initialize() } private void OnDeviceReset(object sender, EventArgs e) { // A bunch of engine stuff menu.ResizeScreen(); renderer.RecreateRenderTargets(); } void ApplyVideoSettings(int width, int height, bool fullscreen, bool vsync); { // Update GraphicsDeviceManager... graphics.PreferredBackBufferWidth = width; graphics.PreferredBackBufferHeight = height; graphics.SynchronizeWithVerticalRetrace = vsync; graphics.IsFullScreen = fullscreen; // Apply! graphics.ApplyChanges(); // A bunch of engine stuff used to be here. It's gone now. } Even if you do not support resizable windows, you need to be prepared for resizes to happen at absolutely any time in your program.","title":"Window Size Changes"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#filesystem-portability-again","text":"Unless you're working with savedata, using System.IO.File is highly discouraged. (And even then, savedata was supposed to be done with Microsoft.Xna.Framework.Storage in the XBLIG world). If you're loading files with File.Open specifically, your game may not even work on PC because the player may have the game installed in a location without write permissions! To load files, use TitleContainer.OpenStream instead. We actually do not recommend Microsoft.Xna.Framework.Storage ; instead you should use SDL3's Storage API (this is provided in our included C# bindings). If you already have established savedata out in the wild, isolate your filesystem calls as much as possible. Lord knows how many times I've done this to make Linux savedata not go directly in $HOME ...","title":"Filesystem Portability (Again)"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#xbox-gdk","text":"Our GDK support is now 100% public source code! Once you have signed the GDK Agreement with Microsoft and have installed the Xbox GDK you can start with the NativeAOT repository . Additionally, developers can request access to our #xbox Discord channel once they join both the FNA and ID@Xbox Discord servers.","title":"Xbox GDK"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#nintendo-switch","text":"While there is no special code needed for Nintendo Switch support (100% of the platform code is in SDL and NativeAOT, two separate projects), all consulting and documentation is private, per NDA requirements. If you are a licensed developer, please get access to SDL-switch (search the licensee forums) and then get in touch with flibit on Discord. If you are NOT a licensed developer, you're on your own. None of us are able to get you hooked up, so please only get in touch AFTER you have Switch SDK access.","title":"Nintendo Switch"},{"location":"appendix/Appendix-B%3A-FNA-on-Consoles/#playstation","text":"While there is no special code needed for PS5 support (100% of the platform code is in SDL and NativeAOT, two separate projects), all consulting and documentation is private, per NDA requirements. If you are a licensed developer, please get access to SDL-playstation (contact Ryan C. Gordon for this) and then get in touch with flibit on Discord. If you are NOT a licensed developer, you're on your own. None of us are able to get you hooked up, so please only get in touch AFTER you have PlayStation SDK access. One detail we can share is that shaders must be precompiled ahead of time; as a result you will need to preprocess your Effect shaders (but you can continue to use the binaries as-is - no, really!). The best way to do this is to make an FNA3D trace of a complete playthrough of your game, then dump SPIR-V binaries with FNA3D's dumping tool . These SPIR-V modules will come in handy to create a working PlayStation renderer.","title":"PlayStation"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/","text":"Appendix C: FNA on Apple Platforms FNA supports deploying to macOS/iOS/tvOS via the .NET SDK. FNA does not have special branches or configurations for each platform; the public master branch of FNA and the configuration you're already used to is exactly what is used to ship for these targets. The platform code is contained entirely in SDL. Getting Started This is the basic guide to getting your game running on macOS/iOS/tvOS. Once these steps are followed, your game should be able to boot on real hardware. Prerequisites In order to build and deploy FNA apps for iOS/tvOS, you must have the following: Mac hardware (required by Apple) The latest .NET SDK for macOS The latest version of Xcode, downloaded from the macOS App Store or from the Apple Developer site The iOS/tvOS workloads for the .NET SDK. Once you have installed .NET on your Mac, run the following commands: sudo dotnet workload install ios sudo dotnet workload install tvos Building fnalibs macOS, iOS, and tvOS libraries are now built automatically and can be downloaded from fnalibs-dailies . You may need to be logged into GitHub to download these. Simulator libraries are not currently provided, so you will need to build those yourself if desired. Note: On newer macOS versions, you may need to run xattr -c *.dylib or xattr -c *.a on these libraries before using them in your projects to avoid security errors. Creating/Publishing a macOS Project A macOS project is essentially the same as any other .NET Core build; the difference is in the publishing process: dotnet publish -r <osx-x64> -c Release --self-contained will produce the executable package. Place the osx version of your fnalibs in the publish directory alongside your executable. Then use install_name_tool -add_rpath @executable_path <your_app_executable_name> to force the application to first look in the executable directory for the fnalibs, instead of /usr/local/lib . For NativeAOT, the directions in Appendix A largely apply here, with these added steps: Build SDL3 from source or install the SDL3 development package from a package manager, then use it to build the other libraries from source. Copy the resulting *.dylib files from SDL3, FNA3D, FAudio, and Theorafile into /usr/local/lib . Build the application. Copy the contents of fnalibs/osx into the generated output directory. Finally, to ensure your application uses the correct search path for SDL3, use install_name_tool -change /usr/local/lib/libSDL3.0.dylib @rpath/libSDL3.0.dylib <my-app-name> . That about covers macOS - iOS/tvOS are a whole different story: Creating an iOS Project Creating a .NET iOS project is almost identical to the process of creating a desktop .NET project . The only difference is that instead of dotnet new console , you must run dotnet new ios . This will generate an \"iOS Application\" template project we can then modify like so: Delete the SceneDelegate.cs and AppDelegate.cs files Update the Info.plist file as follows: Set your application metadata (display name, bundle identifier, etc.) Specify which device orientations you want to support (landscape, portrait, etc.) Change the UIRequiredDeviceCapabilities value from armv7 to arm64 If your game supports game controllers (MFi, Xbox, PlayStation, etc.) add the following: <key>GCSupportedGameControllers</key> <array> <dict> <key>ProfileName</key> <string>ExtendedGamepad</string> </dict> </array> <key>GCSupportsControllerUserInteraction</key> <true/> See this Apple documentation for more information about how to support different kinds of controllers. Add the following to your game's .csproj: <PropertyGroup> <MtouchNoSymbolStrip>true</MtouchNoSymbolStrip> <MtouchExtraArgs>--cxx --gcc_flags \"-L$(MSBuildProjectDirectory) -force_load $(MSBuildProjectDirectory)/libSDL3.a -force_load $(MSBuildProjectDirectory)/libFAudio.a -force_load $(MSBuildProjectDirectory)/libFNA3D.a -force_load $(MSBuildProjectDirectory)/libtheorafile.a -force_load $(MSBuildProjectDirectory)/libmojoshader.a -framework AudioToolbox -framework CoreBluetooth -framework CoreHaptics -framework CoreMotion -framework OpenGLES -framework Metal\"</MtouchExtraArgs> <_ExportSymbolsExplicitly>false</_ExportSymbolsExplicitly> <OptimizePNGs>false</OptimizePNGs> </PropertyGroup> Place all the native libraries in your project directory. They will be linked on build, as specified by the MtouchExtraArgs property you just added to the project. Add a project reference to FNA.Core.csproj, as per usual. And that's it for the project setup! Creating a tvOS Project Creating a .NET tvOS project is almost identical to the process of creating a desktop .NET project . The only difference is that instead of dotnet new console , you must run dotnet new tvos . This will generate a \"tvOS Application\" template project we can then modify like so: Delete the ViewController.cs , ViewController.designer.cs , and AppDelegate.cs files Rename Main.storyboard to LaunchScreen.storyboard and delete the following from line 10 of the file: customClass=\"ViewController\" Update the Info.plist file as follows: Set your application metadata (display name, bundle identifier, etc.) If your game supports game controllers (MFi, Xbox, PlayStation, etc.) add the following: <key>GCSupportedGameControllers</key> <array> <dict> <key>ProfileName</key> <string>ExtendedGamepad</string> </dict> </array> <key>GCSupportsControllerUserInteraction</key> <true/> See this Apple documentation for more information about how to support different kinds of controllers. - Point the app to the correct storyboard file, like so: <!-- Replace this... --> <key>UIMainStoryboardFile</key> <string>Main</string> <!-- ...with this! --> <key>UILaunchStoryboardName</key> <string>LaunchScreen</string> Add the following to your game's .csproj: <PropertyGroup> <MtouchNoSymbolStrip>true</MtouchNoSymbolStrip> <MtouchExtraArgs>--cxx --gcc_flags \"-L$(MSBuildProjectDirectory) -force_load $(MSBuildProjectDirectory)/libSDL3.a -force_load $(MSBuildProjectDirectory)/libFAudio.a -force_load $(MSBuildProjectDirectory)/libFNA3D.a -force_load $(MSBuildProjectDirectory)/libtheorafile.a -force_load $(MSBuildProjectDirectory)/libmojoshader.a $(MSBuildProjectDirectory)/libtvStubs.a -framework AudioToolbox -framework CoreBluetooth -framework CoreHaptics -framework OpenGLES -framework Metal\"</MtouchExtraArgs> <_ExportSymbolsExplicitly>false</_ExportSymbolsExplicitly> <OptimizePNGs>false</OptimizePNGs> </PropertyGroup> Place all the native libraries in your project directory. They will be linked on build, as specified by the MtouchExtraArgs property you just added to the project. Add a project reference to FNA.Core.csproj, as per usual. And that's it for the project setup! Code Changes Initialization To get your game booting on iOS/tvOS, update your Main.cs as follows: static void Main(string[] args) #if __IOS__ || __TVOS__ { // Enable high DPI \"Retina\" support. Trust us, you'll want this. SDL3.SDL.SDL_SetHint(\"FNA_GRAPHICS_ENABLE_HIGHDPI\", \"1\"); // Keep mouse and touch input separate. SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_MOUSE_TOUCH_EVENTS, \"0\"); SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_TOUCH_MOUSE_EVENTS, \"0\"); SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_PEN_TOUCH_EVENTS, \"0\"); // Don't let the accelerometer take over controller slot 0. SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_ACCELEROMETER_AS_JOYSTICK, \"0\"); realArgs = args; SDL3.SDL.SDL_RunApp(0, IntPtr.Zero, FakeMain, IntPtr.Zero); } static string[] realArgs; [ObjCRuntime.MonoPInvokeCallback(typeof(SDL3.SDL.SDL_main_func))] static int FakeMain(int argc, IntPtr argv) { RealMain(realArgs); return 0; } static void RealMain(string[] args) #endif { // your stuff } Background Safety To avoid crashes when your app enters into a background state, add the following to your Game.Update method: if (!IsActive) { SuppressDraw(); } Retina Displays For your app to take full advantage of iPhone and iPad retina displays, you need to set your preferred backbuffer size to the full extent of the display. This should happen at the start of your game and in the Window.OrientationChanged event callback (if your app supports both portrait and landscape orientations). graphics.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width; graphics.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height; On iOS, you may need to set fullscreen true if you run into issues with touches where the statusbar might normally be. tvOS User Storage Note that tvOS does NOT have local storage available. There is temporary storage but it can be wiped by the OS at any time, so standard filesystem code will NOT work past a single instance of the program (this unfortunately includes Microsoft.Xna.Framework.Storage ). To support save data you will need to implement some form of iCloud support, but on the bright side, this means iOS/tvOS can share that data. Our recommended solution for games with a guaranteed total save data size of <1MB is to use TinyKVS . If you're using iCloud and receive an error about iCloudContainerEnvironment when submitting to the App Store, add this to your Entitlements.plist for that submission: <key>com.apple.developer.icloud-container-environment</key> <array> <string>Production</string> </array> Content Changes All your game assets (e.g. your Content/ folder) must be placed inside the Resources/ folder in your project directory. (On tvOS you will need to add this folder manually.) This will ensure they are copied into the app bundle. If you load any resources yourself via a FileStream, the stream must have a file access parameter of FileAccess.Read or you'll get a System.UnauthorizedAccessException. Texture Compression iOS/tvOS do NOT support DXT compression, so you will want to build uncompressed textures at compile time to avoid our fallback decompressor, which wastes lots of time and memory. We are open to considering other texture formats (namely, those supported by Basis ) once we have active use cases to look at. Running Your App Deploying your app to a simulator or physical device can be a bit tricky, but thankfully the .NET documentation can walk you through the process. Please see this page for instructions , but skip to step 5 of the introduction , as the preceding steps are only applicable to MAUI apps. As you might expect, you can substitute ios for tvos in the build line when running a tvOS app. Note that to run your app in the iOS/tvOS simulators on an Intel-based Mac, you must include x86_64 builds of your native libraries. For the fnalibs, these are automatically generated by the build scripts when run with \"ios-sim\" or \"tvos-sim\". Debugging Debugging an FNA game running on a physical device is not yet supported due to bugs with Visual Studio Code's MAUI extension. Profiling See this wiki page from the official repository for instructions on how to profile your app. Troubleshooting If you get a bunch of this spam in your terminal during the build process: Requested but did not find extension point with identifier ... for extension ... don't be alarmed. These messages, while annoying, are harmless and can be ignored. If you don't see any Console.WriteLine messages or exception logs in the Terminal, try checking the Console app on macOS. Select your iOS/tvOS device from the menu on the left, then add your app's name as a Process filter in the top-right. This should show you all the logs relevant to your app. (We're fairly certain the lack of messages is a .NET tooling bug, so hopefully this will be resolved in the future.) If .NET whines that it \"Could not find any provisioning profiles for iOS\", you need to create a dummy Xcode iOS project with the same bundle identifier, which will create a provisioning profile. Then you shouldn't need to touch the Xcode project ever again. If you're not getting any sound, flip the ringer switch on the side of the phone to be unmuted. When you set your phone to silent, it mutes all sound from games, unlike other app types (such as media players). If you get a DllNotFoundException from a native library at runtime, make sure to include the native library in the MtouchExtraArgs property, alongside the fnalibs, like so: -force_load $(MSBuildProjectDirectory)/{your_library}.a If a tvOS build fails because the linker complains about an \"undefined symbol\", that could mean one of two things... You forgot to add a native library to the MtouchExtraArgs property, as described earlier. There is an extern method somewhere in your code (or in the fnalibs) that refers to a function not defined for the tvOS platform. If it's a problem with one of the fnalibs, file an issue and we can take a look. If it's in your code, consider removing the extern declaration or wrapping it inside #if !__TVOS__ .","title":"Appendix C: FNA on Apple Platforms"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#appendix-c-fna-on-apple-platforms","text":"FNA supports deploying to macOS/iOS/tvOS via the .NET SDK. FNA does not have special branches or configurations for each platform; the public master branch of FNA and the configuration you're already used to is exactly what is used to ship for these targets. The platform code is contained entirely in SDL.","title":"Appendix C: FNA on Apple Platforms"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#getting-started","text":"This is the basic guide to getting your game running on macOS/iOS/tvOS. Once these steps are followed, your game should be able to boot on real hardware.","title":"Getting Started"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#prerequisites","text":"In order to build and deploy FNA apps for iOS/tvOS, you must have the following: Mac hardware (required by Apple) The latest .NET SDK for macOS The latest version of Xcode, downloaded from the macOS App Store or from the Apple Developer site The iOS/tvOS workloads for the .NET SDK. Once you have installed .NET on your Mac, run the following commands: sudo dotnet workload install ios sudo dotnet workload install tvos","title":"Prerequisites"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#building-fnalibs","text":"macOS, iOS, and tvOS libraries are now built automatically and can be downloaded from fnalibs-dailies . You may need to be logged into GitHub to download these. Simulator libraries are not currently provided, so you will need to build those yourself if desired. Note: On newer macOS versions, you may need to run xattr -c *.dylib or xattr -c *.a on these libraries before using them in your projects to avoid security errors.","title":"Building fnalibs"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#creatingpublishing-a-macos-project","text":"A macOS project is essentially the same as any other .NET Core build; the difference is in the publishing process: dotnet publish -r <osx-x64> -c Release --self-contained will produce the executable package. Place the osx version of your fnalibs in the publish directory alongside your executable. Then use install_name_tool -add_rpath @executable_path <your_app_executable_name> to force the application to first look in the executable directory for the fnalibs, instead of /usr/local/lib . For NativeAOT, the directions in Appendix A largely apply here, with these added steps: Build SDL3 from source or install the SDL3 development package from a package manager, then use it to build the other libraries from source. Copy the resulting *.dylib files from SDL3, FNA3D, FAudio, and Theorafile into /usr/local/lib . Build the application. Copy the contents of fnalibs/osx into the generated output directory. Finally, to ensure your application uses the correct search path for SDL3, use install_name_tool -change /usr/local/lib/libSDL3.0.dylib @rpath/libSDL3.0.dylib <my-app-name> . That about covers macOS - iOS/tvOS are a whole different story:","title":"Creating/Publishing a macOS Project"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#creating-an-ios-project","text":"Creating a .NET iOS project is almost identical to the process of creating a desktop .NET project . The only difference is that instead of dotnet new console , you must run dotnet new ios . This will generate an \"iOS Application\" template project we can then modify like so: Delete the SceneDelegate.cs and AppDelegate.cs files Update the Info.plist file as follows: Set your application metadata (display name, bundle identifier, etc.) Specify which device orientations you want to support (landscape, portrait, etc.) Change the UIRequiredDeviceCapabilities value from armv7 to arm64 If your game supports game controllers (MFi, Xbox, PlayStation, etc.) add the following: <key>GCSupportedGameControllers</key> <array> <dict> <key>ProfileName</key> <string>ExtendedGamepad</string> </dict> </array> <key>GCSupportsControllerUserInteraction</key> <true/> See this Apple documentation for more information about how to support different kinds of controllers. Add the following to your game's .csproj: <PropertyGroup> <MtouchNoSymbolStrip>true</MtouchNoSymbolStrip> <MtouchExtraArgs>--cxx --gcc_flags \"-L$(MSBuildProjectDirectory) -force_load $(MSBuildProjectDirectory)/libSDL3.a -force_load $(MSBuildProjectDirectory)/libFAudio.a -force_load $(MSBuildProjectDirectory)/libFNA3D.a -force_load $(MSBuildProjectDirectory)/libtheorafile.a -force_load $(MSBuildProjectDirectory)/libmojoshader.a -framework AudioToolbox -framework CoreBluetooth -framework CoreHaptics -framework CoreMotion -framework OpenGLES -framework Metal\"</MtouchExtraArgs> <_ExportSymbolsExplicitly>false</_ExportSymbolsExplicitly> <OptimizePNGs>false</OptimizePNGs> </PropertyGroup> Place all the native libraries in your project directory. They will be linked on build, as specified by the MtouchExtraArgs property you just added to the project. Add a project reference to FNA.Core.csproj, as per usual. And that's it for the project setup!","title":"Creating an iOS Project"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#creating-a-tvos-project","text":"Creating a .NET tvOS project is almost identical to the process of creating a desktop .NET project . The only difference is that instead of dotnet new console , you must run dotnet new tvos . This will generate a \"tvOS Application\" template project we can then modify like so: Delete the ViewController.cs , ViewController.designer.cs , and AppDelegate.cs files Rename Main.storyboard to LaunchScreen.storyboard and delete the following from line 10 of the file: customClass=\"ViewController\" Update the Info.plist file as follows: Set your application metadata (display name, bundle identifier, etc.) If your game supports game controllers (MFi, Xbox, PlayStation, etc.) add the following: <key>GCSupportedGameControllers</key> <array> <dict> <key>ProfileName</key> <string>ExtendedGamepad</string> </dict> </array> <key>GCSupportsControllerUserInteraction</key> <true/> See this Apple documentation for more information about how to support different kinds of controllers. - Point the app to the correct storyboard file, like so: <!-- Replace this... --> <key>UIMainStoryboardFile</key> <string>Main</string> <!-- ...with this! --> <key>UILaunchStoryboardName</key> <string>LaunchScreen</string> Add the following to your game's .csproj: <PropertyGroup> <MtouchNoSymbolStrip>true</MtouchNoSymbolStrip> <MtouchExtraArgs>--cxx --gcc_flags \"-L$(MSBuildProjectDirectory) -force_load $(MSBuildProjectDirectory)/libSDL3.a -force_load $(MSBuildProjectDirectory)/libFAudio.a -force_load $(MSBuildProjectDirectory)/libFNA3D.a -force_load $(MSBuildProjectDirectory)/libtheorafile.a -force_load $(MSBuildProjectDirectory)/libmojoshader.a $(MSBuildProjectDirectory)/libtvStubs.a -framework AudioToolbox -framework CoreBluetooth -framework CoreHaptics -framework OpenGLES -framework Metal\"</MtouchExtraArgs> <_ExportSymbolsExplicitly>false</_ExportSymbolsExplicitly> <OptimizePNGs>false</OptimizePNGs> </PropertyGroup> Place all the native libraries in your project directory. They will be linked on build, as specified by the MtouchExtraArgs property you just added to the project. Add a project reference to FNA.Core.csproj, as per usual. And that's it for the project setup!","title":"Creating a tvOS Project"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#code-changes","text":"","title":"Code Changes"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#initialization","text":"To get your game booting on iOS/tvOS, update your Main.cs as follows: static void Main(string[] args) #if __IOS__ || __TVOS__ { // Enable high DPI \"Retina\" support. Trust us, you'll want this. SDL3.SDL.SDL_SetHint(\"FNA_GRAPHICS_ENABLE_HIGHDPI\", \"1\"); // Keep mouse and touch input separate. SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_MOUSE_TOUCH_EVENTS, \"0\"); SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_TOUCH_MOUSE_EVENTS, \"0\"); SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_PEN_TOUCH_EVENTS, \"0\"); // Don't let the accelerometer take over controller slot 0. SDL3.SDL.SDL_SetHint(SDL3.SDL.SDL_HINT_ACCELEROMETER_AS_JOYSTICK, \"0\"); realArgs = args; SDL3.SDL.SDL_RunApp(0, IntPtr.Zero, FakeMain, IntPtr.Zero); } static string[] realArgs; [ObjCRuntime.MonoPInvokeCallback(typeof(SDL3.SDL.SDL_main_func))] static int FakeMain(int argc, IntPtr argv) { RealMain(realArgs); return 0; } static void RealMain(string[] args) #endif { // your stuff }","title":"Initialization"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#background-safety","text":"To avoid crashes when your app enters into a background state, add the following to your Game.Update method: if (!IsActive) { SuppressDraw(); }","title":"Background Safety"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#retina-displays","text":"For your app to take full advantage of iPhone and iPad retina displays, you need to set your preferred backbuffer size to the full extent of the display. This should happen at the start of your game and in the Window.OrientationChanged event callback (if your app supports both portrait and landscape orientations). graphics.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width; graphics.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height; On iOS, you may need to set fullscreen true if you run into issues with touches where the statusbar might normally be.","title":"Retina Displays"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#tvos-user-storage","text":"Note that tvOS does NOT have local storage available. There is temporary storage but it can be wiped by the OS at any time, so standard filesystem code will NOT work past a single instance of the program (this unfortunately includes Microsoft.Xna.Framework.Storage ). To support save data you will need to implement some form of iCloud support, but on the bright side, this means iOS/tvOS can share that data. Our recommended solution for games with a guaranteed total save data size of <1MB is to use TinyKVS . If you're using iCloud and receive an error about iCloudContainerEnvironment when submitting to the App Store, add this to your Entitlements.plist for that submission: <key>com.apple.developer.icloud-container-environment</key> <array> <string>Production</string> </array>","title":"tvOS User Storage"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#content-changes","text":"All your game assets (e.g. your Content/ folder) must be placed inside the Resources/ folder in your project directory. (On tvOS you will need to add this folder manually.) This will ensure they are copied into the app bundle. If you load any resources yourself via a FileStream, the stream must have a file access parameter of FileAccess.Read or you'll get a System.UnauthorizedAccessException.","title":"Content Changes"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#texture-compression","text":"iOS/tvOS do NOT support DXT compression, so you will want to build uncompressed textures at compile time to avoid our fallback decompressor, which wastes lots of time and memory. We are open to considering other texture formats (namely, those supported by Basis ) once we have active use cases to look at.","title":"Texture Compression"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#running-your-app","text":"Deploying your app to a simulator or physical device can be a bit tricky, but thankfully the .NET documentation can walk you through the process. Please see this page for instructions , but skip to step 5 of the introduction , as the preceding steps are only applicable to MAUI apps. As you might expect, you can substitute ios for tvos in the build line when running a tvOS app. Note that to run your app in the iOS/tvOS simulators on an Intel-based Mac, you must include x86_64 builds of your native libraries. For the fnalibs, these are automatically generated by the build scripts when run with \"ios-sim\" or \"tvos-sim\".","title":"Running Your App"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#debugging","text":"Debugging an FNA game running on a physical device is not yet supported due to bugs with Visual Studio Code's MAUI extension.","title":"Debugging"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#profiling","text":"See this wiki page from the official repository for instructions on how to profile your app.","title":"Profiling"},{"location":"appendix/Appendix-C%3A-FNA-on-Apple-Platforms/#troubleshooting","text":"If you get a bunch of this spam in your terminal during the build process: Requested but did not find extension point with identifier ... for extension ... don't be alarmed. These messages, while annoying, are harmless and can be ignored. If you don't see any Console.WriteLine messages or exception logs in the Terminal, try checking the Console app on macOS. Select your iOS/tvOS device from the menu on the left, then add your app's name as a Process filter in the top-right. This should show you all the logs relevant to your app. (We're fairly certain the lack of messages is a .NET tooling bug, so hopefully this will be resolved in the future.) If .NET whines that it \"Could not find any provisioning profiles for iOS\", you need to create a dummy Xcode iOS project with the same bundle identifier, which will create a provisioning profile. Then you shouldn't need to touch the Xcode project ever again. If you're not getting any sound, flip the ringer switch on the side of the phone to be unmuted. When you set your phone to silent, it mutes all sound from games, unlike other app types (such as media players). If you get a DllNotFoundException from a native library at runtime, make sure to include the native library in the MtouchExtraArgs property, alongside the fnalibs, like so: -force_load $(MSBuildProjectDirectory)/{your_library}.a If a tvOS build fails because the linker complains about an \"undefined symbol\", that could mean one of two things... You forgot to add a native library to the MtouchExtraArgs property, as described earlier. There is an extern method somewhere in your code (or in the fnalibs) that refers to a function not defined for the tvOS platform. If it's a problem with one of the fnalibs, file an issue and we can take a look. If it's in your code, consider removing the extern declaration or wrapping it inside #if !__TVOS__ .","title":"Troubleshooting"},{"location":"appendix/Appendix-D%3A-MonoGame/","text":"Appendix D: MonoGame Compatibility FNA is designed to be a fully-compatible XNA 4.0 Refresh reimplementation that focuses on accuracy and preservation of the XNA catalog. MonoGame, in contrast, is an XNA-like framework that is designed to be like XNA, but not 100% the same. XNA compatibility is likely, but not guaranteed. FNA and MonoGame are mostly compatible with one another, but there are a handful of exceptions that are documented on this page. Code Compatibility API Compatibility MonoGame is mostly XNA4-compatible, but this is not a guarantee. The API is allowed to change mostly at the whims of whoever sends patches and/or has write access to the project. For a successor this makes sense because it is XNA- like , meaning it's meant to feel a lot like XNA without preservation taking priority over what the MonoGame community actually wants. In the context of FNA compatibility, this can be problematic if incompatible APIs are accidentally used. MonoGame API changes are not explicitly marked or documented, so the only way to be sure you're compatible is to constantly build against XNA or FNA. While FNA is extremely strict about API compatibility, we do have formal processes for adding features in the form of extensions , build options , and environment variables , all of which are very clearly marked and are explicitly mentioned in every release that affects them. These features are designed to fill in the absolute worst gaps in the XNA API (mouse events, borderless windows, etc.), and oftentimes this improves MonoGame compatibility. That said, all of these additions are subject to modification and removal, based on the needs of the ecosystem. Project Compatibility MonoGame has a build system that generates project files for each platform, as every platform has a special build with different backend files and platform definitions. Some platforms share project files (DesktopGL for Windows/macOS/Linux, for example), but some platforms have multiple projects (WindowsDX vs. DesktopGL, for example). FNA has only one project file for all platforms and backends, and we do not use platform definitions for any reason and will ALWAYS ban them from the source code, with absolutely zero exceptions. Given that C# is managed code, we have opted to detect platform information at runtime instead, for the few scenarios that platform checks are needed. You are encouraged to do the same in your own code, to allow for single-assembly portability. \"Write Once Run Anywhere\" is usually a fat lie, but \"Build Once Run Anywhere\" is entirely feasible for managed assemblies. Content Compatibility FNA and MonoGame are both compatible with almost all content built by the XNA Content Pipeline. FNA's exceptions are explicitly documented . Content Pipeline MonoGame has their own Content Pipeline tool, called MGCB. It is meant to act as a successor to the XNA Content Pipeline and generates separate content for every platform. FNA does not have and will not have its own Content Pipeline tool. The lead developer of FNA has outlined his reasons for omitting this feature . You are STRONGLY encouraged to develop your own content tools, as they will be simpler, easier to use, more specialized and optimized, and will probably take a few days to make, unlike an XNA-like pipeline which would probably take years to complete. That said, FNA is mostly compatible with MGCB, as MGCB creates data that is remarkably close to XNA-generated content (though it is not compatible with XNA). When building MGCB data for FNA, use the DesktopGL configuration. Incompatible Formats The following content formats are incompatible between FNA and MonoGame: Effects . MonoGame opted to create its own shader format, called MGFX. Each platform has its own MGFX file that only works on that platform. FNA continues to support DXBC and Effect framework binaries generated by both the XNA pipeline as well as FXC , the offline compiler for DirectX shaders and effects, from the June 2010 DirectX SDK (ideally; if you have your own FXC from a Windows SDK that works then that's fine too). The one effect binary will work on every platform and backend. To compile an existing XNA effect file with FXC: fxc.exe /T fx_2_0 MyEffect.fx /Fo MyEffect.fxb You can also call FXC as part of your MSBuild process, as Andrew Russell's FNA template does . Note that FXC is usable with Wine, meaning shaders can be developed on Linux and macOS. Songs/Videos . MonoGame has various formats and backends used on various platforms, but FNA uses Ogg Vorbis (or QOA) and Ogg Theora for all platforms. MGCB FNA Support Lennard Fonteijn has provided specialized code for MGCB that should allow for the use of MGCB with FNA, even for the formats listed above. You can find this code here: OggSongProcessor and FxcEffectProcessor for FNA and MGCB Platform Compatibility As a reminder, while MonoGame targets each platform with a different project version, FNA supports all of its platforms with exactly one project with no special versions. Platform FNA MonoGame Windows Direct3D \u2714\ufe0f \u2714\ufe0f Windows Vulkan \u2714\ufe0f \u274c Windows OpenGL \u2714\ufe0f \u2714\ufe0f Linux Vulkan \u2714\ufe0f \u274c Linux OpenGL \u2714\ufe0f \u2714\ufe0f macOS Metal \u2714\ufe0f \u274c macOS OpenGL \u2714\ufe0f \u2714\ufe0f iOS/tvOS Metal \u2714\ufe0f \u274c iOS/tvOS OpenGL \u2714\ufe0f \u2714\ufe0f Nintendo Switch [1] \u2714\ufe0f \u2714\ufe0f Xbox One [2] \u2714\ufe0f \u2714\ufe0f Xbox Series X/S \u2714\ufe0f \ud83d\udea7 PlayStation 4 \ud83d\udea7 \u2714\ufe0f PlayStation 5 \u2714\ufe0f \u2714\ufe0f Android \u274c[3] \u2714\ufe0f For Nintendo Switch, FNA uses Vulkan/OpenGL while MonoGame uses NVN. For Xbox One, FNA uses GDK and MonoGame uses XDK. Android FNA is unofficially supported via FNADroid","title":"Appendix D: MonoGame Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#appendix-d-monogame-compatibility","text":"FNA is designed to be a fully-compatible XNA 4.0 Refresh reimplementation that focuses on accuracy and preservation of the XNA catalog. MonoGame, in contrast, is an XNA-like framework that is designed to be like XNA, but not 100% the same. XNA compatibility is likely, but not guaranteed. FNA and MonoGame are mostly compatible with one another, but there are a handful of exceptions that are documented on this page.","title":"Appendix D: MonoGame Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#code-compatibility","text":"","title":"Code Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#api-compatibility","text":"MonoGame is mostly XNA4-compatible, but this is not a guarantee. The API is allowed to change mostly at the whims of whoever sends patches and/or has write access to the project. For a successor this makes sense because it is XNA- like , meaning it's meant to feel a lot like XNA without preservation taking priority over what the MonoGame community actually wants. In the context of FNA compatibility, this can be problematic if incompatible APIs are accidentally used. MonoGame API changes are not explicitly marked or documented, so the only way to be sure you're compatible is to constantly build against XNA or FNA. While FNA is extremely strict about API compatibility, we do have formal processes for adding features in the form of extensions , build options , and environment variables , all of which are very clearly marked and are explicitly mentioned in every release that affects them. These features are designed to fill in the absolute worst gaps in the XNA API (mouse events, borderless windows, etc.), and oftentimes this improves MonoGame compatibility. That said, all of these additions are subject to modification and removal, based on the needs of the ecosystem.","title":"API Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#project-compatibility","text":"MonoGame has a build system that generates project files for each platform, as every platform has a special build with different backend files and platform definitions. Some platforms share project files (DesktopGL for Windows/macOS/Linux, for example), but some platforms have multiple projects (WindowsDX vs. DesktopGL, for example). FNA has only one project file for all platforms and backends, and we do not use platform definitions for any reason and will ALWAYS ban them from the source code, with absolutely zero exceptions. Given that C# is managed code, we have opted to detect platform information at runtime instead, for the few scenarios that platform checks are needed. You are encouraged to do the same in your own code, to allow for single-assembly portability. \"Write Once Run Anywhere\" is usually a fat lie, but \"Build Once Run Anywhere\" is entirely feasible for managed assemblies.","title":"Project Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#content-compatibility","text":"FNA and MonoGame are both compatible with almost all content built by the XNA Content Pipeline. FNA's exceptions are explicitly documented .","title":"Content Compatibility"},{"location":"appendix/Appendix-D%3A-MonoGame/#content-pipeline","text":"MonoGame has their own Content Pipeline tool, called MGCB. It is meant to act as a successor to the XNA Content Pipeline and generates separate content for every platform. FNA does not have and will not have its own Content Pipeline tool. The lead developer of FNA has outlined his reasons for omitting this feature . You are STRONGLY encouraged to develop your own content tools, as they will be simpler, easier to use, more specialized and optimized, and will probably take a few days to make, unlike an XNA-like pipeline which would probably take years to complete. That said, FNA is mostly compatible with MGCB, as MGCB creates data that is remarkably close to XNA-generated content (though it is not compatible with XNA). When building MGCB data for FNA, use the DesktopGL configuration.","title":"Content Pipeline"},{"location":"appendix/Appendix-D%3A-MonoGame/#incompatible-formats","text":"The following content formats are incompatible between FNA and MonoGame: Effects . MonoGame opted to create its own shader format, called MGFX. Each platform has its own MGFX file that only works on that platform. FNA continues to support DXBC and Effect framework binaries generated by both the XNA pipeline as well as FXC , the offline compiler for DirectX shaders and effects, from the June 2010 DirectX SDK (ideally; if you have your own FXC from a Windows SDK that works then that's fine too). The one effect binary will work on every platform and backend. To compile an existing XNA effect file with FXC: fxc.exe /T fx_2_0 MyEffect.fx /Fo MyEffect.fxb You can also call FXC as part of your MSBuild process, as Andrew Russell's FNA template does . Note that FXC is usable with Wine, meaning shaders can be developed on Linux and macOS. Songs/Videos . MonoGame has various formats and backends used on various platforms, but FNA uses Ogg Vorbis (or QOA) and Ogg Theora for all platforms.","title":"Incompatible Formats"},{"location":"appendix/Appendix-D%3A-MonoGame/#mgcb-fna-support","text":"Lennard Fonteijn has provided specialized code for MGCB that should allow for the use of MGCB with FNA, even for the formats listed above. You can find this code here: OggSongProcessor and FxcEffectProcessor for FNA and MGCB","title":"MGCB FNA Support"},{"location":"appendix/Appendix-D%3A-MonoGame/#platform-compatibility","text":"As a reminder, while MonoGame targets each platform with a different project version, FNA supports all of its platforms with exactly one project with no special versions. Platform FNA MonoGame Windows Direct3D \u2714\ufe0f \u2714\ufe0f Windows Vulkan \u2714\ufe0f \u274c Windows OpenGL \u2714\ufe0f \u2714\ufe0f Linux Vulkan \u2714\ufe0f \u274c Linux OpenGL \u2714\ufe0f \u2714\ufe0f macOS Metal \u2714\ufe0f \u274c macOS OpenGL \u2714\ufe0f \u2714\ufe0f iOS/tvOS Metal \u2714\ufe0f \u274c iOS/tvOS OpenGL \u2714\ufe0f \u2714\ufe0f Nintendo Switch [1] \u2714\ufe0f \u2714\ufe0f Xbox One [2] \u2714\ufe0f \u2714\ufe0f Xbox Series X/S \u2714\ufe0f \ud83d\udea7 PlayStation 4 \ud83d\udea7 \u2714\ufe0f PlayStation 5 \u2714\ufe0f \u2714\ufe0f Android \u274c[3] \u2714\ufe0f For Nintendo Switch, FNA uses Vulkan/OpenGL while MonoGame uses NVN. For Xbox One, FNA uses GDK and MonoGame uses XDK. Android FNA is unofficially supported via FNADroid","title":"Platform Compatibility"},{"location":"appendix/Appendix-F%3A-Upcoming-Support-Changes/","text":"Appendix F: Upcoming Support Changes While very rare, FNA does occasionally make changes to its support matrix, usually to migrate existing platforms to new system requirements or development environments. In extremely rare cases, certain features may even be removed from FNA. This page is meant to track the more extreme cases, so that developers can plan their own products' development accordingly. glibc Support Calendar As of February 2025, FNA requires glibc 2.31 or newer. The fnalibs build OS is Steam Linux Runtime 3.0 (Sniper) . There are currently no plans to update the glibc requirement at this time.","title":"Appendix F: Upcoming Support Changes"},{"location":"appendix/Appendix-F%3A-Upcoming-Support-Changes/#appendix-f-upcoming-support-changes","text":"While very rare, FNA does occasionally make changes to its support matrix, usually to migrate existing platforms to new system requirements or development environments. In extremely rare cases, certain features may even be removed from FNA. This page is meant to track the more extreme cases, so that developers can plan their own products' development accordingly.","title":"Appendix F: Upcoming Support Changes"},{"location":"appendix/Appendix-F%3A-Upcoming-Support-Changes/#glibc-support-calendar","text":"As of February 2025, FNA requires glibc 2.31 or newer. The fnalibs build OS is Steam Linux Runtime 3.0 (Sniper) . There are currently no plans to update the glibc requirement at this time.","title":"glibc Support Calendar"}]}